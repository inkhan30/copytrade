#include <Trade/Trade.mqh>

CTrade trade;

// Input parameters
input double LotSize = 0.01;              // Lot size
input ulong StopLossPoints = 5000;        // Initial Stop Loss in points
input ulong ProfitStepPoints = 1200;     // Profit Step in points
input int ConsecutiveBars = 3;           // Number of consecutive bars for trend confirmation
input bool EnableCounterTrade = true;    // Enable/Disable counter-trade feature

// Global variables
datetime currentBarTime;
double highestPrice;    // For buy positions
double lowestPrice;     // For sell positions
double currentTP;
double currentSL;
double newTP_Global = 0;
double newSL_Global = 0;
bool counterTradeOpened = false; // Flag to track if counter-trade was opened

int OnInit()
{
    currentBarTime = 0;
    highestPrice = 0;
    lowestPrice = 0;
    counterTradeOpened = false;
    return(INIT_SUCCEEDED);
}

bool CheckBuySignal()
{
    MqlRates rates[4];
    if(CopyRates(_Symbol, _Period, 0, 4, rates) != 4) return false;
    
    // Check for 3 consecutive bullish candles
    for(int i = 1; i <= ConsecutiveBars; i++)
    {
        if(rates[i].close <= rates[i-1].close) return false;
    }
    return true;
}

bool CheckSellSignal()
{
    MqlRates rates[4];
    if(CopyRates(_Symbol, _Period, 0, 4, rates) != 4) return false;
    
    // Check for 3 consecutive bearish candles
    for(int i = 1; i <= ConsecutiveBars; i++)
    {
        if(rates[i].close >= rates[i-1].close) return false;
    }
    return true;
}

void ManageTrades()
{
    bool positionExists = PositionSelect(_Symbol);
    
    if(!positionExists)
    {
        counterTradeOpened = false; // Reset flag when no positions exist
        if(CheckBuySignal())
        {
            double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
            currentSL = ask - (StopLossPoints * _Point);
            currentTP = ask + (ProfitStepPoints * _Point);
            highestPrice = ask;
            trade.Buy(LotSize, _Symbol, ask, currentSL, currentTP, "Bullish Trend Buy");
        }
        else if(CheckSellSignal())
        {
            double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            currentSL = bid + (StopLossPoints * _Point);
            currentTP = bid - (ProfitStepPoints * _Point);
            lowestPrice = bid;
            trade.Sell(LotSize, _Symbol, bid, currentSL, currentTP, "Bearish Trend Sell");
        }
    }
}

void CheckCounterTradeCondition()
{
    if(!EnableCounterTrade || counterTradeOpened || !PositionSelect(_Symbol)) return;

    long type = PositionGetInteger(POSITION_TYPE);
    double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    double currentPrice = type == POSITION_TYPE_BUY ? 
                        SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                        SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    // Calculate 50% of SL distance
    double halfSLDistance = StopLossPoints * _Point / 2.0;
    
    if(type == POSITION_TYPE_BUY)
    {
        if(currentPrice <= (entryPrice - halfSLDistance))
        {
            // Open counter sell trade
            double newSL = currentPrice + (StopLossPoints * _Point);
            double newTP = currentPrice - (ProfitStepPoints * _Point);
            if(trade.Sell(LotSize, _Symbol, currentPrice, newSL, newTP, "Counter Sell Trade"))
            {
                counterTradeOpened = true;
                Print("Opened counter sell trade at 50% of buy SL");
            }
        }
    }
    else if(type == POSITION_TYPE_SELL)
    {
        if(currentPrice >= (entryPrice + halfSLDistance))
        {
            // Open counter buy trade
            double newSL = currentPrice - (StopLossPoints * _Point);
            double newTP = currentPrice + (ProfitStepPoints * _Point);
            if(trade.Buy(LotSize, _Symbol, currentPrice, newSL, newTP, "Counter Buy Trade"))
            {
                counterTradeOpened = true;
                Print("Opened counter buy trade at 50% of sell SL");
            }
        }
    }
}

void CheckAndAdjustTPSL()
{
    if(!PositionSelect(_Symbol)) return;

    long type = PositionGetInteger(POSITION_TYPE);
    double price = type == POSITION_TYPE_BUY ? 
                 SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
                 SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    double step = ProfitStepPoints * _Point;

    if(type == POSITION_TYPE_BUY)
    {
        // Track highest price since entry
        if(price > highestPrice) highestPrice = price;
        
        // Check if price moved enough to adjust
        if(highestPrice >= currentTP)  
        {
            double newTP = currentTP + step;
            double newSL = currentTP - (step/2);  // Lock SL at previous TP
            Print("STEP::",step," :: newTP : ",newTP," :: highestPrice::",highestPrice);
            if(newTP_Global < newTP){              
               newTP_Global = newTP;
               newSL_Global = newSL;
               if(trade.PositionModify(_Symbol, newSL, newTP))
               {
                   currentTP = newTP;
                   currentSL = newSL;
                   Print("1. Buy adjusted - TP: ", newTP, " SL: ", newSL);
               }
            }
        }
    }
    else if(type == POSITION_TYPE_SELL)
    {
        // Track lowest price since entry
        if(price < lowestPrice) lowestPrice = price;
        
        // Check if price moved enough to adjust
        if(lowestPrice <= currentTP)
        {
            double newTP = currentTP - step;
            double newSL = currentTP + (step/2);  // Lock SL at previous TP
            
            if(newTP_Global==0){
               newTP_Global = newTP;
               newSL_Global = newSL;
            
               if(trade.PositionModify(_Symbol, newSL, newTP))
               {
                   currentTP = newTP;
                   currentSL = newSL;
                   Print("1. Sell adjusted - TP: ", newTP, " SL: ", newSL);
               }
            }else{
               if(newTP_Global > newTP){
                  if(trade.PositionModify(_Symbol, newSL, newTP))
                  {
                      currentTP = newTP;
                      currentSL = newSL;
                      Print("2. Sell adjusted - TP: ", newTP, " SL: ", newSL);
                  }
               }
            }
        }
    }
}

void OnTick()
{
    datetime time[1];
    if(CopyTime(_Symbol, _Period, 0, 1, time) == 1)
    {
        if(currentBarTime != time[0])
        {
            currentBarTime = time[0];
            ManageTrades();
        }
    }
    CheckAndAdjustTPSL();
    CheckCounterTradeCondition();
}