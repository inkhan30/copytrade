//+------------------------------------------------------------------+
//|                                         Supertrend_EMA_EA.mq5    |
//|                                                                  |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "Generated by AI"
#property link      ""
#property version   "1.05"

//--- Includes
#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>

//--- Input Parameters
input group "1. Supertrend Settings"
input int                InpSTPeriod = 10;           // ATR Period
input double             InpSTMultiplier = 3.0;      // ATR Multiplier

input group "2. Moving Average Settings"
input int                InpMAPeriod = 21;           // EMA Period
input ENUM_APPLIED_PRICE InpMAPrice = PRICE_CLOSE;   // Applied Price

input group "3. Risk & Money Management"
input double             InpRiskPercent = 2.0;       // Risk per Trade (%)
input int                InpStopLossPoints = 150;    // SL (Points), 0=Use Swing
input int                InpTakeProfitPoints = 300;  // TP (Points), 0=Use Trailing ST

input group "4. Trade Settings"
input ulong              InpMagicNumber = 24681;     // Magic Number
input string             InpTradeComment = "ST-EMA"; // Trade Comment

//--- Global Variables
int               handleSupertrend;
int               handleEMA;
double            supertrendBuffer[];
double            maBuffer[];

CTrade            trade;
CPositionInfo     positionInfo;

datetime          currentBarTime;
double            initialStopLossPrice;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- Get indicator handles
   handleSupertrend = iCustom(_Symbol, _Period, "Examples\\Supertrend", InpSTPeriod, InpSTMultiplier);
   handleEMA = iMA(_Symbol, _Period, InpMAPeriod, 0, MODE_EMA, InpMAPrice);

//--- Check if handles are valid
   if(handleSupertrend == INVALID_HANDLE)
     {
      Print("Error creating Supertrend handle. Error: ", GetLastError());
      return(INIT_FAILED);
     }
   if(handleEMA == INVALID_HANDLE)
     {
      Print("Error creating EMA handle. Error: ", GetLastError());
      return(INIT_FAILED);
     }

//--- Set arrays as series
   ArraySetAsSeries(supertrendBuffer, true);
   ArraySetAsSeries(maBuffer, true);

//--- Set magic number for the trade object
   trade.SetExpertMagicNumber(InpMagicNumber);

//--- Get the current bar time to avoid immediate trading on start
   currentBarTime = iTime(_Symbol, _Period, 0);

   Print("EA initialized successfully.");
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- Release indicator handles
   if(handleSupertrend != INVALID_HANDLE)
      IndicatorRelease(handleSupertrend);
   if(handleEMA != INVALID_HANDLE)
      IndicatorRelease(handleEMA);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- Check for new bar
   if(!IsNewBar())
      return;

//--- Check minimum bars and update indicators
   if(Bars(_Symbol, _Period) < 100)
     {
      Print("Not enough bars to trade.");
      return;
     }

//--- Get indicator values for the last 3 bars
   if(CopyBuffer(handleSupertrend, 0, 0, 3, supertrendBuffer) < 3)
      return;
   if(CopyBuffer(handleEMA, 0, 0, 3, maBuffer) < 3)
      return;

//--- Get current and previous price data
   double currentClose = iClose(_Symbol, _Period, 0);
   double currentLow   = iLow(_Symbol, _Period, 0);
   double currentHigh  = iHigh(_Symbol, _Period, 0);
   double prevClose    = iClose(_Symbol, _Period, 1);
   double prevLow      = iLow(_Symbol, _Period, 1);
   double prevHigh     = iHigh(_Symbol, _Period, 1);

   double stCurrent = supertrendBuffer[0]; // Value on current (just closed) bar
   double stPrev    = supertrendBuffer[1]; // Value on previous bar
   double maCurrent = maBuffer[0];         // MA value on current bar

//--- Check for entry signals if no position is open
   if(!HasOpenPosition())
     {
      CheckForLongEntry(currentClose, prevLow, stCurrent, stPrev, maCurrent);
      CheckForShortEntry(currentClose, prevHigh, stCurrent, stPrev, maCurrent);
     }
   else
     {
      //--- Check for exit conditions if a position is open (Trailing via Supertrend)
      CheckForExit(currentClose, stCurrent);
     }
  }

//+------------------------------------------------------------------+
//| Check if a new bar has formed                                    |
//+------------------------------------------------------------------+
bool IsNewBar()
  {
   datetime newBarTime = iTime(_Symbol, _Period, 0);
   if(newBarTime != currentBarTime)
     {
      currentBarTime = newBarTime;
      return true;
     }
   return false;
  }

//+------------------------------------------------------------------+
//| Check if there is an open position by this EA                    |
//+------------------------------------------------------------------+
bool HasOpenPosition()
  {
   return positionInfo.Select(_Symbol) && positionInfo.Magic() == InpMagicNumber;
  }

//+------------------------------------------------------------------+
//| Check for a valid LONG entry signal                              |
//+------------------------------------------------------------------+
void CheckForLongEntry(double close, double prevLow, double stCurr, double stPrev, double ma)
  {
// 1. Trend Filter: Price above EMA
   bool trendOk = (close > ma);
// 2. Trigger: Previous candle touched or crossed below ST
   bool touchOk = (prevLow <= stPrev);
// 3. Confirmation: Current candle closed above ST
   bool confirmationOk = (close > stCurr);

   if(trendOk && touchOk && confirmationOk)
     {
      double ask       = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double slPrice   = CalculateStopLossPrice(true, prevLow);
      double tpPrice   = CalculateTakeProfitPrice(true, ask, slPrice);
      double lotSize   = CalculateLotSize(ask, slPrice);

      if(lotSize > 0)
         trade.Buy(lotSize, _Symbol, ask, slPrice, tpPrice, InpTradeComment);
     }
  }

//+------------------------------------------------------------------+
//| Check for a valid SHORT entry signal                             |
//+------------------------------------------------------------------+
void CheckForShortEntry(double close, double prevHigh, double stCurr, double stPrev, double ma)
  {
// 1. Trend Filter: Price below EMA
   bool trendOk = (close < ma);
// 2. Trigger: Previous candle touched or crossed above ST
   bool touchOk = (prevHigh >= stPrev);
// 3. Confirmation: Current candle closed below ST
   bool confirmationOk = (close < stCurr);

   if(trendOk && touchOk && confirmationOk)
     {
      double bid       = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double slPrice   = CalculateStopLossPrice(false, prevHigh);
      double tpPrice   = CalculateTakeProfitPrice(false, bid, slPrice);
      double lotSize   = CalculateLotSize(bid, slPrice);

      if(lotSize > 0)
         trade.Sell(lotSize, _Symbol, bid, slPrice, tpPrice, InpTradeComment);
     }
  }

//+------------------------------------------------------------------+
//| Check if an open position should be exited by Supertrend         |
//+------------------------------------------------------------------+
void CheckForExit(double currentPrice, double supertrendValue)
  {
   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

//--- If it's a BUY position and price closes below ST, close it.
   if(posType == POSITION_TYPE_BUY && currentPrice < supertrendValue)
     {
      trade.PositionClose(_Symbol);
     }
//--- If it's a SELL position and price closes above ST, close it.
   if(posType == POSITION_TYPE_SELL && currentPrice > supertrendValue)
     {
      trade.PositionClose(_Symbol);
     }
  }

//+------------------------------------------------------------------+
//| Calculate the Stop Loss price                                    |
//+------------------------------------------------------------------+
double CalculateStopLossPrice(bool isLong, double triggerPrice)
  {
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double slPrice = 0.0;

//--- If using fixed points SL
   if(InpStopLossPoints > 0)
     {
      if(isLong)
         slPrice = triggerPrice - (InpStopLossPoints * point);
      else
         slPrice = triggerPrice + (InpStopLossPoints * point);
     }
   else
     {
      //--- If SL Points is 0, use the trigger price (swing low/high) as the SL.
      slPrice = triggerPrice;
     }
   return NormalizeDouble(slPrice, _Digits);
  }

//+------------------------------------------------------------------+
//| Calculate the Take Profit price                                  |
//+------------------------------------------------------------------+
double CalculateTakeProfitPrice(bool isLong, double entryPrice, double slPrice)
  {
//--- If TP Points is 0, we will rely on the Supertrend trailing exit. Return 0.0 for no fixed TP.
   if(InpTakeProfitPoints <= 0)
      return 0.0;

   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double tpPrice;

   if(isLong)
      tpPrice = entryPrice + (InpTakeProfitPoints * point);
   else
      tpPrice = entryPrice - (InpTakeProfitPoints * point);

   return NormalizeDouble(tpPrice, _Digits);
  }

//+------------------------------------------------------------------+
//| Calculate position size based on risk % and stop loss            |
//+------------------------------------------------------------------+
double CalculateLotSize(double entryPrice, double slPrice)
  {
   double balance       = AccountInfoDouble(ACCOUNT_EQUITY);
   double riskMoney     = balance * (InpRiskPercent / 100.0);
   double point         = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double tickSize      = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue     = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);

//--- If SL is zero (e.g., using trailing exit only), use a default minimal lot
   if(slPrice == 0.0)
      return SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);

//--- Calculate the number of points between entry and SL
   double slPoints = MathAbs(entryPrice - slPrice) / point;

//--- Calculate the value per point for 1 lot
   double pointValue = (tickValue / tickSize) * point; // Value of a point move for 1 lot

//--- Calculate the potential loss per 1 lot at the given SL distance
   double potentialLossPerLot = slPoints * pointValue;

//--- If the potential loss is zero or negative, return minimal lot
   if(potentialLossPerLot <= 0)
      return SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);

//--- Calculate the required lot size to risk the specified amount
   double lotSize = riskMoney / potentialLossPerLot;

//--- Normalize and validate the lot size
   return NormalizeLotSize(lotSize);
  }

//+------------------------------------------------------------------+
//| Normalize the lot size to the broker's requirements              |
//+------------------------------------------------------------------+
double NormalizeLotSize(double lot)
  {
   double minLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

   lot = MathRound(lot / lotStep) * lotStep;
   lot = MathMax(lot, minLot);
   lot = MathMin(lot, maxLot);

   return lot;
  }
//+------------------------------------------------------------------+