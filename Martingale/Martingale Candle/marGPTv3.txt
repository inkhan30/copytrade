// high profit 
//+------------------------------------------------------------------+
//| Expert Advisor: Hedging Martingale Strategy (Inputs in Pips)     |
//+------------------------------------------------------------------+
input bool     EnableStrategy      = true;
input int      ConsecutiveCandles  = 2;
input double   InitialLotSize      = 0.01;
input int      InitialTPPips       = 10;        // Take-profit in pips
input string   CustomLotSequence   = "0.02,0.04,0.05,0.06,0.08,0.10,0.12,0.14,0.17,0.21,0.25,0.30,0.36,0.43,0.51,0.62,0.74,0.89,1.06,1.28,1.53,1.84,2.21,2.65,2.90,3.25,3.65,3.95,4.3,4.65,5,5.5,6.2,6.9,7.4,8.2,8.85,9.2,9.75,10.2";
input int      ProfitTargetPips    = 10;        // Total profit target in pips
input int      MaxTrades           = 40;
input int      MagicNumber         = 123456;

#include <Trade\Trade.mqh>
CTrade trade;

int    direction            = 0;    // 1=Buy, -1=Sell
bool   initialTradeOpened   = false;
double lotSequence[];
#define PIP 10

//+------------------------------------------------------------------+
int OnInit()
//| Expert initialization                                          |
//+------------------------------------------------------------------+
{
   StringToLotArray(CustomLotSequence);
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
void StringToLotArray(const string str)
//| Parse custom lot sequence string                              |
//+------------------------------------------------------------------+
{
   string temp[];
   int    count = StringSplit(str, ',', temp);
   ArrayResize(lotSequence, count);
   for(int i = 0; i < count; i++)
      lotSequence[i] = StringToDouble(temp[i]);
}

//+------------------------------------------------------------------+
void OnTick()
//| Expert tick function                                          |
//+------------------------------------------------------------------+
{
   if(!EnableStrategy)
      return;

   int totalTrades = CountOpenTrades();

   // Initial trend-based entry
   if(totalTrades == 0)
   {
      if(CheckConsecutiveCandles(direction))
      {
         initialTradeOpened = true;
         double entryPrice = SymbolInfoDouble(_Symbol, direction == 1 ? SYMBOL_ASK : SYMBOL_BID);
         trade.SetExpertMagicNumber(MagicNumber);
         Print("Opening initial ", (direction==1?"Buy":"Sell"), " trade at ", entryPrice);
         trade.PositionOpen(
            _Symbol,
            direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
            InitialLotSize,
            entryPrice,
            0,
            entryPrice + (direction==1? InitialTPPips : -InitialTPPips) * PIP * _Point
         );
      }
   }
   // Hedging logic
   else if(totalTrades < MaxTrades)
   {
      ManageHedging();
   }

   // Combined profit target
   double totalProfit = GetTotalUnrealizedProfit();
   if(totalProfit >= ProfitTargetPips * PIP * _Point)
   {
      Print("Profit target reached. Closing all trades. Total P/L = ", totalProfit);
      CloseAllTrades();
      initialTradeOpened = false;
   }
}

//+------------------------------------------------------------------+
int CountOpenTrades()
//| Count open positions by this EA                                |
//+------------------------------------------------------------------+
{
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         count++;
   }
   return(count);
}

//+------------------------------------------------------------------+
bool CheckConsecutiveCandles(int &dir)
//| Check for consecutive candles                                   |
//+------------------------------------------------------------------+
{
   bool bullish = true, bearish = true;
   double openArr[1], closeArr[1];

   for(int i = 1; i <= ConsecutiveCandles; i++)
   {
      if(CopyOpen(_Symbol, _Period, i, 1, openArr) != 1 ||
         CopyClose(_Symbol, _Period, i, 1, closeArr) != 1)
         return(false);

      if(closeArr[0] <= openArr[0]) bullish = false;
      if(closeArr[0] >= openArr[0]) bearish = false;
   }

   if(bullish)  { dir = 1;  return(true); }
   if(bearish)  { dir = -1; return(true); }
   return(false);
}

//+------------------------------------------------------------------+
void ManageHedging()
//| Hedging based on M1 candle close                                |
//+------------------------------------------------------------------+
{
   double lastPrice = GetLastPositionPrice();
   if(lastPrice == 0) return;

   int openCount = CountOpenTrades();
   if(openCount >= MaxTrades) return;

   MqlRates rates[1];
   if(CopyRates(_Symbol, PERIOD_M1, 1, 1, rates) != 1) return;
   double m1Close = rates[0].close;

   bool conditionMet = (direction == 1 && m1Close < lastPrice) ||
                       (direction == -1 && m1Close > lastPrice);

   if(conditionMet && openCount < ArraySize(lotSequence) + 1)
   {
      double lot = lotSequence[openCount - 1];
      trade.SetExpertMagicNumber(MagicNumber);
      PrintFormat("Hedge %d: %s at %.2f, Lot=%.2f", openCount,
                  (direction==1?"Buy":"Sell"), m1Close, lot);
      trade.PositionOpen(
         _Symbol,
         direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
         lot,
         m1Close,
         0,
         0
      );
   }
}

//+------------------------------------------------------------------+
double GetTotalUnrealizedProfit()
//| Get total unrealized profit                                     |
//+------------------------------------------------------------------+
{
   double profit = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         profit += PositionGetDouble(POSITION_PROFIT);
   }
   return(profit);
}

//+------------------------------------------------------------------+
void CloseAllTrades()
//| Close all positions                                             |
//+------------------------------------------------------------------+
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         trade.PositionClose(ticket);
   }
}

//+------------------------------------------------------------------+
double GetLastPositionPrice()
//| Get last position's entry price                                 |
//+------------------------------------------------------------------+
{
   datetime latestTime  = 0;
   double   latestPrice = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;

      datetime posTime = (datetime)PositionGetInteger(POSITION_TIME);
      if(posTime > latestTime)
      {
         latestTime  = posTime;
         latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      }
   }
   return(latestPrice);
}
