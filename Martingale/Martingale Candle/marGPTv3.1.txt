// need some changes
//+------------------------------------------------------------------+
//| Expert Advisor: M1 Candle Close Hedging Strategy                 |
//+------------------------------------------------------------------+
#property copyright "Copyright 2023"
#property version   "1.00"
#property strict

// Input parameters
input bool     EnableStrategy      = true;
input int      ConsecutiveCandles  = 2;
input double   InitialLotSize      = 0.01;
input int      InitialTPPips       = 10;        // Take-profit in pips
input string   CustomLotSequence   = "0.02,0.04,0.05,0.06,0.08,0.10,0.12,0.14,0.17,0.21,0.25,0.30,0.36,0.43,0.51,0.62,0.74,0.89,1.06,1.28,1.53,1.84,2.21,2.65,2.90,3.25,3.65,3.95,4.3,4.65,5,5.5,6.2,6.9,7.4,8.2,8.85,9.2,9.75,10.2";
input int      ProfitTargetPips    = 10;        // Total profit target in pips
input int      MaxTrades           = 40;
input int      MagicNumber         = 123456;

#include <Trade\Trade.mqh>
CTrade trade;

// Global variables
int direction = 0;                // 1 for Buy, -1 for Sell
double initialTradePrice = 0;     // Price of first trade
datetime lastCandleTime;          // Track M1 candle times
double lotSequence[];             // Array for custom lot sizes
#define PIP 10

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   StringToLotArray(CustomLotSequence);
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Parse custom lot sequence string                                 |
//+------------------------------------------------------------------+
void StringToLotArray(string str)
{
   string temp[];
   int count = StringSplit(str, ',', temp);
   ArrayResize(lotSequence, count);
   for(int i = 0; i < count; i++)
      lotSequence[i] = StringToDouble(temp[i]);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!EnableStrategy) return;

   int totalTrades = CountOpenTrades();
   
   // Open initial trade
   if(totalTrades == 0)
   {
      initialTradePrice = 0; // Reset when no trades
      if(CheckConsecutiveCandles(direction))
      {
         double price = SymbolInfoDouble(_Symbol, direction == 1 ? SYMBOL_ASK : SYMBOL_BID);
         trade.SetExpertMagicNumber(MagicNumber);
         trade.PositionOpen(_Symbol, direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
                           InitialLotSize, price, 0,
                           price + (direction == 1 ? InitialTPPips : -InitialTPPips) * PIP * _Point);
         initialTradePrice = price; // Store initial trade price
      }
   }
   // Manage existing trades
   else if(totalTrades < MaxTrades)
   {
      ManageHedging();
   }

   // Check profit target
   if(GetTotalUnrealizedProfit() >= ProfitTargetPips * PIP * _Point)
   {
      CloseAllTrades();
      initialTradePrice = 0;
   }
}

//+------------------------------------------------------------------+
//| Manage hedging based on M1 closes                                |
//+------------------------------------------------------------------+
void ManageHedging()
{
   datetime currentTime = iTime(_Symbol, PERIOD_M1, 0);
   if(currentTime == lastCandleTime) return;

   double closeArray[1];
   if(CopyClose(_Symbol, PERIOD_M1, 1, 1, closeArray) != 1) return;
   
   int hedgeCount = CountOpenTrades() - 1;
   
   // Check hedging condition
   if(closeArray[0] < initialTradePrice)
   {
      // Verify lot sequence bounds and max trades
      if(hedgeCount < ArraySize(lotSequence) && hedgeCount < (MaxTrades - 1))
      {
         trade.SetExpertMagicNumber(MagicNumber);
         OpenHedgeTrade(hedgeCount);
      }
   }

   lastCandleTime = currentTime;
}

//+------------------------------------------------------------------+
//| Open hedge position                                              |
//+------------------------------------------------------------------+
void OpenHedgeTrade(int hedgeIndex)
{
   double lot = lotSequence[hedgeIndex];
   double price = SymbolInfoDouble(_Symbol, direction == 1 ? SYMBOL_ASK : SYMBOL_BID);
   
   trade.PositionOpen(_Symbol, 
                     direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
                     lot, price, 0, 0);
}

//+------------------------------------------------------------------+
//| Count open positions                                             |
//+------------------------------------------------------------------+
int CountOpenTrades()
{
   int count = 0;
   for(int i = PositionsTotal()-1; i >=0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         count++;
   }
   return count;
}

//+------------------------------------------------------------------+
//| Check consecutive candles                                        |
//+------------------------------------------------------------------+
bool CheckConsecutiveCandles(int &dir)
{
   bool bullish = true, bearish = true;
   double openArray[1], closeArray[1];

   for(int i = 1; i <= ConsecutiveCandles; i++)
   {
      if(CopyOpen(_Symbol, _Period, i, 1, openArray) != 1 || 
         CopyClose(_Symbol, _Period, i, 1, closeArray) != 1)
         return false;

      if(closeArray[0] <= openArray[0]) bullish = false;
      if(closeArray[0] >= openArray[0]) bearish = false;
   }

   if(bullish) { dir = 1; return true; }
   if(bearish) { dir = -1; return true; }
   return false;
}

//+------------------------------------------------------------------+
//| Close all positions                                              |
//+------------------------------------------------------------------+
void CloseAllTrades()
{
   for(int i = PositionsTotal()-1; i >=0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         trade.PositionClose(PositionGetString(POSITION_SYMBOL));
   }
}

//+------------------------------------------------------------------+
//| Calculate total unrealized profit                                |
//+------------------------------------------------------------------+
double GetTotalUnrealizedProfit()
{
   double profit = 0;
   for(int i = PositionsTotal()-1; i >=0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         profit += PositionGetDouble(POSITION_PROFIT);
   }
   return profit;
}
//+------------------------------------------------------------------+