//+------------------------------------------------------------------+
//| Expert Advisor: Reliable v1                                      |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, Reliable Trading Systems"
#property link      "www.reliablesystems.com"
#property version   "001.000"
#property strict

//===========================================
//             Common Settings
//===========================================
input string   GeneralSettings         = "------ General Settings ------";
input bool     EnableStrategy          = true;        // Enable/Disable trading strategy
input string   TradeSymbol             = "";          // Symbol to trade (empty = current chart)
input int      MagicNumber             = 123456;      // Unique EA identifier
input double   EmergencyEquityStopPerc = 2.0;         // Emergency equity % level (0=disable)
input bool     EnableEquityStop        = false;       // Enable equity stop protection
input double   MaxEquityDrawdownPercent = 20.0;       // Max allowed equity drawdown percentage
input int      MaxSlippagePips         = 5;           // Maximum allowed slippage in pips
input bool     IncorporateManualTrades = true;        // Incorporate manual trades into EA management
input string   NotificationPhoneNumber = "";          // Phone number for SMS alerts

//===========================================
//          Initial Trade Settings
//===========================================
input string   InitialSettings         = "------ Initial Trade Settings ------";
input bool     EnableInitialTrades     = true;        // Enable/Disable initial trades
input int      ConsecutiveCandles      = 2;           // Number of consecutive candles required
input double   InitialLotSize          = 0.02;        // Initial trade lot size (0=auto)
input int      InitialTPPips           = 500;         // Initial take-profit in pips
input bool     UseAutoLotSize          = false;       // Enable auto lot sizing
input double   RiskPercentPerTrade     = 1.0;         // Risk % per trade for auto lot

//===========================================
//          Main Hedge Settings
//===========================================
input string   HedgeSettings           = "------ Main Hedge Settings ------";
input bool     EnableHedging           = true;        // Enable main hedging logic
input double   LotMultiplier           = 1.5;         // Multiplier for each subsequent hedge position
input string   CustomLotSizes          = "0.5,1,3,9,15,20,25"; // Custom lot sizes (leave empty to use multiplier)
input int      MaxTrades               = 30;          // Maximum trades allowed
input double   ProfitTargetUSD         = 375.0;       // Base profit target in account currency
input string   CustomProfitTargets     = "";          // Custom profit targets (comma separated)
input bool     UseDrawdownCondition    = true;        // Enable drawdown condition for hedging
input int      MaxHedgeDrawdownPips    = 0;           // Minimum drawdown (pips) required to hedge
input string   HedgeDrawdownPips       = "1500,3000,5000,7500,10000,12500,14000"; // Manual pips per hedge

//===========================================
//          Profit Target Settings
//===========================================
input string   ProfitTargetSettings    = "------ Profit Target Settings ------";
input bool     EnableProfitTarget      = false;       // Enable profit target
input double   ProfitTargetFixed       = 100.0;       // Profit target in account currency
input int      ProfitTargetCooldownHours = 4;         // Cooldown after reaching target (hours)

//===========================================
//          Time Exit Settings
//===========================================
input string   TimeExitSettings        = "------ Time Exit Settings ------";
input bool     EnableTimeExit          = true;         // Enable time-based exit for initial+hedge
input double   MaxTimeForInitialHedge  = 2.0;          // Max hours for initial + first hedge
input double   BreakevenThreshold      = 5.0;          // USD threshold for breakeven condition

//===========================================
//        Hedge Time Exit Settings
//===========================================
input string   TimeHedgeSettings       = "------ Hedge Time Exit Settings ------";
input bool     EnableHedgeTimeExit     = true;        // Enable time-based exit for individual hedge positions
input double   MaxHedgeHours           = 2.0;         // Maximum hours for individual hedge positions
input double   HedgeTimeExitThreshold  = 10.0;        // USD profit threshold for hedge time exit
input bool     CloseOnlyProfitableHedges = true;      // Close only profitable hedges on time exit
input double   ReopenLotMultiplier     = 1.5;         // Lot size multiplier when reopening closed hedges (1.0 = same lot)
input bool     EnableReopenTrailing    = true;        // Enable trailing profit for reopened hedges
input double   ReopenTrailingProfit    = 15.0;        // USD profit to activate trailing for reopened hedges
input double   ReopenTrailingDistance  = 5.0;         // USD distance for trailing stop

//===========================================
//        Alternate Hedge Settings
//===========================================
input string   AltHedgeSettings        = "------ Alternate Hedge Settings ------";
input bool     EnableAlternateHedge    = true;        // Enable additional standard lot after alternate hedges
input double   AlternateLotSize        = 1.0;         // Lot size for alternate hedge trades
input int      AlternateHedgeStart     = 2;           // Start after this many main hedges
input int      AlternateHedgeEvery     = 2;           // Place alternate hedge every X hedges
input int      AlternateHedgeTPPips    = 20;          // Take profit for alternate hedges in pips (0=disable)
input bool     AllowReentryAtSamePrice = true;        // Allow re-entry at same price level
input bool     AltHedgeTrailingStop    = true;        // Enable trailing for alternate hedges
input int      AltHedgeTrailStartPips  = 30;          // Pips profit to activate trailing for alt hedges
input int      AltHedgeTrailDistPips   = 15;          // Pips distance for trailing stop for alt hedges

//===========================================
//         Reverse Hedge Settings
//===========================================
input string   ReverseSettings         = "------ Reverse Hedge Settings ------";
input bool     EnableReverseHedging    = true;        // Enable reverse hedging logic
input int      ReverseHedgeAfterTrades = 5;           // Start reverse hedging after X same-side trades
input double   ReverseHedgeTriggerPips = 200;         // Pip distance to trigger reverse hedge
input double   ReverseLotMultiplier    = 1.5;         // Multiplier for reverse lot sequence
input double   ReverseInitialLotSize   = 0.01;        // Initial lot size for reverse hedge
input int      MaxReverseTrades        = 25;          // Maximum reverse trades allowed
input int      ReverseHedgeTPPips      = 500;         // Take profit for reverse hedges in pips

//===========================================
//        Dynamic Trailing Settings
//===========================================
input string   TrailingSettings        = "------ Dynamic Trailing Settings ------";
input bool     EnableGroupTrailing     = true;        // Enable group trailing SL
input double   BaseProfitPerTrade      = 5.0;         // Base profit per trade to activate trailing
input double   TrailingStepUSD         = 1.0;         // Profit increment to move SL
input double   MinTrailingDistanceUSD  = 2.0;         // Minimum distance from current profit

//===========================================
//             Time Settings
//===========================================
input string   TimeSettings            = "------ Time Settings ------";
input bool     EnableTimeFilter        = true;        // Enable time filter
input bool     UseLocalComputerTime    = true;        // Use local computer time (true) or broker time (false)
input int      StartHourIST            = 23;          // Start hour (23 = 11 PM)
input int      StartMinuteIST          = 0;           // Start minute (0)
input int      EndHourIST              = 6;           // End hour (6 = 6 AM)
input int      EndMinuteIST            = 0;           // End minute (0)
input bool     DrawdownOnlyInTradingHours = true;     // Apply drawdown only during trading hours
input int      DrawdownStartHourIST    = 23;          // Drawdown start hour (23 = 11 PM)
input int      DrawdownStartMinuteIST  = 0;           // Drawdown start minute (0)
input int      DrawdownEndHourIST      = 6;           // Drawdown end hour (6 = 6 AM)
input int      DrawdownEndMinuteIST    = 0;           // Drawdown end minute (0)

//===========================================
//             Filter Settings
//===========================================
input string   FilterSettings          = "------ Filter Settings ------";
input bool     UseEMAFilter            = true;        // Enable/disable EMA filter
input int      EMA_Period              = 200;         // EMA period for trend filter
input bool     UseRSIFilter            = false;       // Enable RSI filter for initial trade
input int      RSI_Period              = 14;          // RSI period
input double   RSI_Overbought          = 70.0;        // RSI overbought level
input double   RSI_Oversold            = 30.0;        // RSI oversold level
input bool     UseMACDFilter           = false;       // Enable MACD filter for initial trade
input int      MACDFast                = 12;          // MACD fast EMA
input int      MACDSlow                = 26;          // MACD slow EMA
input int      MACDSignal              = 9;           // MACD signal SMA
input bool     EnableVolumeFilter      = false;       // Enable volume filter for initial trades
input double   VolumeThreshold         = 1.0;         // Minimum volume to allow initial trade (in lots)
input bool     EnableNewsFilter        = true;        // Enable news filter
input int      PreNewsMinutes          = 30;          // Minutes before news to stop trading
input int      PostNewsMinutes         = 60;          // Minutes after news to resume trading

//===========================================
//            Trade Enable Settings
//===========================================
input string   TradeSettings           = "------ Trade Settings ------";
input bool     EnableHedges            = true;        // Enable/Disable hedging trades

//===========================================
//            Halt Period Settings
//===========================================
input string   HaltSettings            = "------ Halt Period Settings ------";
input int      HaltPeriodSeconds       = 60;          // Wait time (seconds) after closing trades before new initial trade

//===========================================
//        Risk Management Settings
//===========================================
input string   RiskSettings            = "------ Risk Management ------";
input bool     EnableRecoveryMode      = true;        // Enable recovery mode
input double   RecoveryDrawdownPercent = 15.0;        // Drawdown % to activate recovery
input double   RecoveryLotMultiplier   = 0.7;         // Lot multiplier in recovery mode

//===========================================
//          Notification Settings
//===========================================
input string   NotifySettings          = "------ Notification Settings ------";
input bool     EnableNotifications     = true;        // Enable status notifications

//===========================================
//             Display Settings
//===========================================
input string   DisplaySettings         = "------ Display Settings ------";
input bool     EnableChartDisplay      = true;        // Enable/Disable chart panel display
input color    HeaderColor             = C'0,40,80';  // Dark blue
input color    ValueColor              = clrGold;     // Gold
input color    BackgroundColor         = C'30,30,30'; // Dark gray
input int      FontSize                = 10;          // Display font size

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\AccountInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>
CTrade trade;
CPositionInfo positionInfo;
CAccountInfo accountInfo;
CHistoryOrderInfo historyOrder;

// Trade comment identifiers
#define INITIAL_COMMENT "Reliable_Initial"
#define HEDGE_COMMENT   "Reliable_Hedge"
#define ALT_COMMENT     "Reliable_Alt"
#define REVERSE_COMMENT "Reliable_Reverse"
#define MANUAL_COMMENT  "Reliable_Manual"

// Global Variables
int direction = 0;                  // 1 for Buy, -1 for Sell
bool initialTradeOpened = false;    // Flag for initial trade
double lotSequence[];               // Array for dynamic lot sizes
double reverseLotSequence[];        // Array for reverse lot sizes
datetime lastHedgeTime = 0;         // Last hedge position time
datetime lastReverseHedgeTime = 0;  // Last reverse hedge time
datetime lastAlternateHedgeTime = 0;// Last alternate hedge time
double initialEntryPrice = 0;       // Initial trade entry price
double lastMainEntryPrice = 0;      // Last main sequence entry price
double lastReverseEntryPrice = 0;   // Last reverse sequence entry price
bool emergencyStopTriggered = false;// Emergency stop flag
double highestBalance = 0;          // Highest account balance achieved
string currentStatus = "Initializing EA...";  // Current EA status message
int emaHandle = INVALID_HANDLE;
int rsiHandle = INVALID_HANDLE;
int macdHandle = INVALID_HANDLE;
bool useCustomLots = false;
int sameDirectionCount = 0;         // Count of same-direction trades
int reverseTradeCount = 0;          // Count of reverse trades
#define PIP 10                      // Pip multiplier (10 for 5-digit brokers)
string lastLogMessage = "";         // Last log message for display
double lastProfitCheck = 0;         // Last recorded profit for comparison
datetime lastTradeCloseTime = 0;    // Time when last trade was closed
bool inHaltPeriod = false;          // Flag for halt period
datetime initialBarTime = 0;        // Bar time when initial trade was opened
double alternateHedgePrices[];      // Array to store alternate hedge entry prices
bool inRecoveryMode = false;        // Recovery mode flag
double dailyProfit = 0;             // Today's profit
int dailyTrades = 0;                // Today's trade count
datetime lastDailyReset = 0;        // Last daily reset time
double maxDailyDrawdown = 0;        // Max daily drawdown
double winRate = 0;                 // Win rate percentage
double riskRewardRatio = 0;         // Risk-reward ratio
string currentSymbol;               // Symbol being traded
bool manualTradeDetected = false;   // Flag for detected manual trades
int manualDrawdownPips[];           // Array for manual drawdown pips
bool useManualDrawdown = false;     // Flag to use manual drawdown values
int currentRequiredDrawdown = 0;    // Current required drawdown for next hedge
double groupTrailingLevel = 0;      // Current trailing SL level
double peakGroupProfit = 0;         // Highest profit achieved
bool trailingActive = false;        // Trailing state flag
double activationLevel = 0;         // Current activation level for trailing
double customProfitTargets[];       // Array for custom profit targets
datetime initialTradeOpenTime = 0;  // Time when initial trade was opened
datetime firstHedgeOpenTime = 0;    // Time when first hedge was opened
bool timeExitTriggered = false;     // Flag for time exit
double peakProfit = 0;              // Track peak profit for trailing

// Hedge position tracking structure
struct HedgePosition {
   double entryPrice;
   double lotSize;
   int direction;
   bool closedInProfit;
   datetime closeTime;
   string comment;
};

// Hedge tracking arrays
HedgePosition closedHedges[];        // Array to store closed hedge positions
HedgePosition manuallyClosedHedges[];// Array to store manually closed hedge positions
datetime lastManualCloseCheck = 0;   // Last time manual close check was performed

// Hedge time exit tracking structure
struct HedgeInfo {
   ulong ticket;
   datetime openTime;
   double openPrice;
   double lotSize;
   int direction;
   string comment;
};

HedgeInfo hedgePositions[];          // Array to track open hedge positions

// Profit target variables
double totalProfitSinceReset = 0;   // Total profit since last reset
bool profitTargetReached = false;   // Flag when profit target is reached
datetime cooldownStartTime = 0;     // Time when cooldown started

//+------------------------------------------------------------------+
//| Reset EA state function                                          |
//+------------------------------------------------------------------+
void ResetEAState()
{
   sameDirectionCount = 0;
   reverseTradeCount = 0;
   initialTradeOpened = false;
   direction = 0;
   initialBarTime = 0;
   initialTradeOpenTime = 0;
   firstHedgeOpenTime = 0;
   timeExitTriggered = false;
   manualTradeDetected = false;
   peakProfit = 0;
   lastMainEntryPrice = 0;
   lastReverseEntryPrice = 0;
   trailingActive = false;
   groupTrailingLevel = 0;
   peakGroupProfit = 0;
   activationLevel = 0;
   ArrayResize(alternateHedgePrices, 0);
   totalProfitSinceReset = 0;
   ArrayResize(closedHedges, 0);
   ArrayResize(manuallyClosedHedges, 0);
   ArrayResize(hedgePositions, 0);
}

//+------------------------------------------------------------------+
//| Safe Point Value Retrieval                                       |
//+------------------------------------------------------------------+
double GetCurrentPoint()
{
   double point = SymbolInfoDouble(currentSymbol, SYMBOL_POINT);
   if(point <= 0) {
      point = 0.00001;
      static bool warned = false;
      if(!warned) {
         Log("Warning: Invalid point value detected. Using backup value");
         warned = true;
      }
   }
   return point;
}

//+------------------------------------------------------------------+
//| Error Description Function                                       |
//+------------------------------------------------------------------+
string ErrorDescription(int error_code)
{
   switch(error_code)
   {
      case 0:     return "No error";
      case 1:     return "No error, but result unknown";
      case 2:     return "Common error";
      case 3:     return "Invalid parameters";
      case 4:     return "Trade server is busy";
      case 5:     return "Old version of the client terminal";
      case 6:     return "No connection with trade server";
      case 7:     return "Not enough rights";
      case 8:     return "Too frequent requests";
      case 9:     return "Malfunctional trade operation";
      case 64:    return "Account disabled";
      case 65:    return "Invalid account";
      case 128:   return "Trade timeout";
      case 129:   return "Invalid price";
      case 130:   return "Invalid stops";
      case 131:   return "Invalid trade volume";
      case 132:   return "Market is closed";
      case 133:   return "Trade is disabled";
      case 134:   return "Not enough money";
      case 135:   return "Price changed";
      case 136:   return "Off quotes";
      case 137:   return "Broker is busy";
      case 138:   return "Requote";
      case 139:   return "Order is locked";
      case 140:   return "Long positions only allowed";
      case 141:   return "Too many requests";
      case 145:   return "Modification denied because order is too close to market";
      case 146:   return "Trade context is busy";
      case 147:   return "Expirations are denied by broker";
      case 148:   return "The amount of open and pending orders has reached the limit";
      case 149:   return "An attempt to open an order opposite to the existing one when hedging is disabled";
      case 150:   return "An attempt to close an order contravening the FIFO rule";
      default:    return "Unknown error";
   }
}

//+------------------------------------------------------------------+
//| Notification function with phone number                          |
//+------------------------------------------------------------------+
void SendStatusNotification(string message)
{
    if(!EnableNotifications) return;
    
    #ifdef __MQL5__
        SendNotification("Reliable: " + message);
        if(NotificationPhoneNumber != "") {
            SendNotification("Reliable" + NotificationPhoneNumber);
        }
    #else
        Alert("Reliable: " + message);
        if(NotificationPhoneNumber != "") {
            Alert("Reliable" + NotificationPhoneNumber);
        }
    #endif
    
    Print("Notification sent: ", message);
}

//+------------------------------------------------------------------+
//| Enhanced logging function                                        |
//+------------------------------------------------------------------+
void Log(string message)
{
   string timestamp = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS);
   string logEntry = StringFormat("[%s] %s", timestamp, message);
   Print(logEntry);
   lastLogMessage = logEntry;
   
   if(StringFind(message, "Status:") == 0) {
      currentStatus = StringSubstr(message, 8);
   }
}

//+------------------------------------------------------------------+
//| Parse custom lot sequence string                                 |
//+------------------------------------------------------------------+
void StringToLotArray(string str)
{
   string temp[];
   int count = StringSplit(str, ',', temp);
   ArrayResize(lotSequence, count);
   for(int i = 0; i < count; i++) {
      lotSequence[i] = StringToDouble(temp[i]);
   }
   Log(StringFormat("Custom lot sequence parsed: %d entries", count));
}

//+------------------------------------------------------------------+
//| Generate lot sequence using multiplier                           |
//+------------------------------------------------------------------+
void GenerateLotSequence()
{
   ArrayResize(lotSequence, MaxTrades-1);
   double currentLot = InitialLotSize * LotMultiplier;
   
   for(int i = 0; i < MaxTrades-1; i++) {
      lotSequence[i] = NormalizeDouble(currentLot, 2);
      currentLot *= LotMultiplier;
   }
   Log(StringFormat("Generated lot sequence: %d entries", MaxTrades-1));
}

//+------------------------------------------------------------------+
//| Generate reverse lot sequence                                    |
//+------------------------------------------------------------------+
void GenerateReverseLotSequence()
{
   ArrayResize(reverseLotSequence, MaxReverseTrades);
   double currentLot = ReverseInitialLotSize;
   
   for(int i = 0; i < MaxReverseTrades; i++) {
      reverseLotSequence[i] = NormalizeDouble(currentLot, 2);
      currentLot *= ReverseLotMultiplier;
   }
   Log(StringFormat("Reverse lot sequence generated: %d entries", MaxReverseTrades));
}

//+------------------------------------------------------------------+
//| Calculate profit from EA trades since last reset                 |
//+------------------------------------------------------------------+
double CalculateTotalProfitSinceReset()
{
   double profit = 0;
   
   MqlDateTime today;
   TimeCurrent(today);
   today.hour = 0;
   today.min = 0;
   today.sec = 0;
   datetime startTime = cooldownStartTime > 0 ? cooldownStartTime : lastDailyReset;
   
   HistorySelect(startTime, TimeCurrent());
   int totalDeals = HistoryDealsTotal();
   
   for(int i = 0; i < totalDeals; i++) {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket == 0) continue;
      
      bool isEATrade = (HistoryDealGetInteger(ticket, DEAL_MAGIC) == MagicNumber);
      bool isManualTrade = (IncorporateManualTrades && HistoryDealGetInteger(ticket, DEAL_MAGIC) == 0);
      
      if(!isEATrade && !isManualTrade) continue;
      if(HistoryDealGetInteger(ticket, DEAL_ENTRY) != DEAL_ENTRY_OUT) continue;
      
      double dealProfit = HistoryDealGetDouble(ticket, DEAL_PROFIT) + 
                         HistoryDealGetDouble(ticket, DEAL_SWAP) + 
                         HistoryDealGetDouble(ticket, DEAL_COMMISSION);
      profit += dealProfit;
   }
   
   for(int i = PositionsTotal()-1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber || 
         (IncorporateManualTrades && PositionGetInteger(POSITION_MAGIC) == 0)) {
         profit += PositionGetDouble(POSITION_PROFIT);
      }
   }
   
   return profit;
}

//+------------------------------------------------------------------+
//| Calculate auto lot size based on risk percentage                 |
//+------------------------------------------------------------------+
double CalculateAutoLotSize(double riskPercent)
{
   double riskAmount = accountInfo.Balance() * (riskPercent / 100.0);
   double tickValue = SymbolInfoDouble(currentSymbol, SYMBOL_TRADE_TICK_VALUE);
   double stopLossPips = 50;
   
   if(tickValue <= 0 || stopLossPips <= 0) {
      Log("Warning: Cannot calculate auto lot size. Using default");
      return InitialLotSize;
   }
   
   double point = GetCurrentPoint();
   double lotSize = riskAmount / (stopLossPips * PIP * point * tickValue);
   lotSize = NormalizeDouble(lotSize, 2);
   
   if(inRecoveryMode) {
      lotSize *= RecoveryLotMultiplier;
      lotSize = NormalizeDouble(lotSize, 2);
   }
   
   return MathMax(lotSize, 0.01);
}

//+------------------------------------------------------------------+
//| Check for high-impact news events                                |
//+------------------------------------------------------------------+
bool IsNewsEvent()
{
   if(!EnableNewsFilter) return false;
   
   datetime now = TimeCurrent();
   
   datetime newsEvents[] = {
      D'2023.12.15 15:00',
      D'2023.12.20 14:00'
   };
   
   for(int i = 0; i < ArraySize(newsEvents); i++) {
      if(now > newsEvents[i] - PreNewsMinutes*60 && 
         now < newsEvents[i] + PostNewsMinutes*60) {
         return true;
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| Check RSI filter condition                                       |
//+------------------------------------------------------------------+
bool CheckRSIFilter(int &dir)
{
   if(!UseRSIFilter) return true;
   
   double rsi[1];
   if(CopyBuffer(rsiHandle, 0, 0, 1, rsi) != 1) {
      Log("Error: Failed to copy RSI buffer!");
      return false;
   }
   
   if(dir == 1 && rsi[0] < RSI_Oversold) return true;
   if(dir == -1 && rsi[0] > RSI_Overbought) return true;
   
   Log(StringFormat("RSI filter blocking trade: %.2f", rsi[0]));
   return false;
}

//+------------------------------------------------------------------+
//| Check MACD filter condition                                      |
//+------------------------------------------------------------------+
bool CheckMACDFilter(int &dir)
{
   if(!UseMACDFilter) return true;
   
   double macd[1], signal[1];
   if(CopyBuffer(macdHandle, 0, 0, 1, macd) != 1 || 
      CopyBuffer(macdHandle, 1, 0, 1, signal) != 1) {
      Log("Error: Failed to copy MACD buffers!");
      return false;
   }
   
   if(dir == 1 && macd[0] > signal[0]) return true;
   if(dir == -1 && macd[0] < signal[0]) return true;
   
   Log(StringFormat("MACD filter blocking trade: MACD=%.4f, Signal=%.4f", macd[0], signal[0]));
   return false;
}

//+------------------------------------------------------------------+
//| Check recovery mode condition                                    |
//+------------------------------------------------------------------+
void CheckRecoveryMode()
{
   if(!EnableRecoveryMode) return;
   
   double equity = accountInfo.Equity();
   double balance = accountInfo.Balance();
   double drawdownPercent = 0;
   
   if(balance > 0) {
      drawdownPercent = (1 - equity/balance) * 100;
   }
   else {
      drawdownPercent = 100;
   }
   
   if(drawdownPercent >= RecoveryDrawdownPercent) {
      if(!inRecoveryMode) {
         Log("Entering recovery mode! Drawdown: " + DoubleToString(drawdownPercent, 1) + "%");
         SendStatusNotification("RECOVERY MODE ACTIVATED");
         inRecoveryMode = true;
      }
   } else if(inRecoveryMode) {
      Log("Exiting recovery mode");
      inRecoveryMode = false;
   }
}

//+------------------------------------------------------------------+
//| Manage trailing stops for alternate hedges                       |
//+------------------------------------------------------------------+
void ManageAltHedgeTrailing()
{
   if(!AltHedgeTrailingStop) return;
   
   double point = GetCurrentPoint();
   
   for(int i = PositionsTotal()-1; i >=0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      if(PositionGetString(POSITION_COMMENT) != ALT_COMMENT) continue;
      
      double currentProfit = PositionGetDouble(POSITION_PROFIT);
      double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      
      double trailStart = AltHedgeTrailStartPips * PIP * point;
      double trailDist = AltHedgeTrailDistPips * PIP * point;
   }
}

//+------------------------------------------------------------------+
//| Update daily statistics                                          |
//+------------------------------------------------------------------+
void UpdateDailyStats()
{
   MqlDateTime today;
   TimeCurrent(today);
   today.hour = 0;
   today.min = 0;
   today.sec = 0;
   datetime startOfDay = StructToTime(today);
   
   if(lastDailyReset != startOfDay) {
      dailyProfit = 0;
      dailyTrades = 0;
      maxDailyDrawdown = 0;
      lastDailyReset = startOfDay;
      
      totalProfitSinceReset = 0;
      profitTargetReached = false;
      cooldownStartTime = 0;
      
      Log("Daily statistics reset for new trading day");
   }
   
   dailyProfit = CalculateTotalProfitSinceReset();
   
   double equity = accountInfo.Equity();
   double balance = accountInfo.Balance();
   double drawdown = 0;
   
   if(balance > 0) {
      drawdown = (1 - equity/balance) * 100;
   }
   else {
      drawdown = 100;
   }
   
   if(drawdown > maxDailyDrawdown) maxDailyDrawdown = drawdown;
}

//+------------------------------------------------------------------+
//| Calculate win rate and risk-reward ratio                         |
//+------------------------------------------------------------------+
void CalculatePerformanceMetrics()
{
   int wins = 0;
   int losses = 0;
   double totalProfit = 0;
   double totalLoss = 0;
   
   HistorySelect(0, TimeCurrent());
   int totalDeals = HistoryDealsTotal();
   
   for(int i = 0; i < totalDeals; i++) {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket == 0) continue;
      if(HistoryDealGetInteger(ticket, DEAL_MAGIC) != MagicNumber) continue;
      if(HistoryDealGetInteger(ticket, DEAL_ENTRY) != DEAL_ENTRY_OUT) continue;
      
      double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
      if(profit > 0) {
         wins++;
         totalProfit += profit;
      } else {
         losses++;
         totalLoss += MathAbs(profit);
      }
   }
   
   int totalTrades = wins + losses;
   winRate = (totalTrades > 0) ? (double)wins / totalTrades * 100 : 0;
   
   double avgWin = (wins > 0) ? totalProfit / wins : 0;
   double avgLoss = (losses > 0) ? totalLoss / losses : 0;
   riskRewardRatio = (avgLoss > 0) ? avgWin / avgLoss : 0;
}

//+------------------------------------------------------------------+
//| Get broker time in UTC                                           |
//+------------------------------------------------------------------+
datetime GetBrokerTime()
{
   if(UseLocalComputerTime) 
      return TimeLocal();
   return TimeCurrent();
}

//+------------------------------------------------------------------+
//| Convert UTC to IST                                               |
//+------------------------------------------------------------------+
datetime UTCtoIST(datetime utcTime)
{
   return utcTime + 19800;
}

//+------------------------------------------------------------------+
//| Check if current time is within drawdown hours (IST)             |
//+------------------------------------------------------------------+
bool IsDrawdownTime()
{
   datetime brokerTime = GetBrokerTime();
   datetime istTime = UTCtoIST(brokerTime);
   MqlDateTime istStruct;
   TimeToStruct(istTime, istStruct);
   
   int currentMinutes = istStruct.hour * 60 + istStruct.min;
   int startMinutes = DrawdownStartHourIST * 60 + DrawdownStartMinuteIST;
   int endMinutes = DrawdownEndHourIST * 60 + DrawdownEndMinuteIST;

   if(startMinutes >= endMinutes) {
      return (currentMinutes >= startMinutes || currentMinutes < endMinutes);
   } else {
      return (currentMinutes >= startMinutes && currentMinutes < endMinutes);
   }
}

//+------------------------------------------------------------------+
//| Check if current time is within trading hours (IST)              |
//+------------------------------------------------------------------+
bool IsTradingTime()
{
   if(!EnableTimeFilter) return true;
   
   datetime brokerTime = GetBrokerTime();
   datetime istTime = UTCtoIST(brokerTime);
   MqlDateTime istStruct;
   TimeToStruct(istTime, istStruct);
   
   int currentMinutes = istStruct.hour * 60 + istStruct.min;
   int startMinutes = StartHourIST * 60 + StartMinuteIST;
   int endMinutes = EndHourIST * 60 + EndMinuteIST;

   if(startMinutes >= endMinutes) {
      return (currentMinutes >= startMinutes || currentMinutes < endMinutes);
   } else {
      return (currentMinutes >= startMinutes && currentMinutes < endMinutes);
   }
}

//+------------------------------------------------------------------+
//| Get current EMA value                                            |
//+------------------------------------------------------------------+
double GetEMAValue()
{
   if(emaHandle == INVALID_HANDLE) return 0;
   
   double emaValue[1];
   if(CopyBuffer(emaHandle, 0, 0, 1, emaValue) != 1) {
      Log("Error: Failed to copy EMA buffer!");
      return 0;
   }
   return emaValue[0];
}

//+------------------------------------------------------------------+
//| Check EMA filter condition                                       |
//+------------------------------------------------------------------+
bool CheckEMAFilter(int &dir)
{
   if(!UseEMAFilter) return true;
   
   double emaValue = GetEMAValue();
   if(emaValue == 0) return false;
   
   double currentClose = iClose(currentSymbol, _Period, 1);
   
   if(currentClose > emaValue) {
      dir = 1;
      return true;
   }
   else if(currentClose < emaValue) {
      dir = -1;
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Calculate dynamic equity stop level                              |
//+------------------------------------------------------------------+
double CalculateEquityStopLevel()
{
   double currentBalance = accountInfo.Balance();
   if(currentBalance > highestBalance) {
      highestBalance = currentBalance;
   }
   
   if(EmergencyEquityStopPerc > 0) {
      return NormalizeDouble(highestBalance * (EmergencyEquityStopPerc / 100.0), 2);
   }
   return 0;
}

//+------------------------------------------------------------------+
//| Check emergency equity stop condition                            |
//+------------------------------------------------------------------+
bool CheckEmergencyStop()
{
   double equityStopLevel = CalculateEquityStopLevel();
   if(equityStopLevel <= 0) return false;
   
   double equity = accountInfo.Equity();
   if(equity <= equityStopLevel && !emergencyStopTriggered) {
      emergencyStopTriggered = true;
      Log("Status: EMERGENCY STOP ACTIVATED! Closing ALL EA trades...");
      SendStatusNotification(currentStatus);
      CloseAllEATrades();
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Calculate dynamic profit target based on hedge count             |
//+------------------------------------------------------------------+
double CalculateProfitTarget()
{
   if(ArraySize(customProfitTargets) > 0) {
      int index = sameDirectionCount - 2;
      if(index < 0) return 0;
      if(index < ArraySize(customProfitTargets)) {
         return customProfitTargets[index];
      } else if(ArraySize(customProfitTargets) > 0) {
         return customProfitTargets[ArraySize(customProfitTargets)-1];
      }
   }
   
   if(sameDirectionCount <= 1) return 0;
   
   if(sameDirectionCount == 2)
      return 0.3 * ProfitTargetUSD;
   else if(sameDirectionCount == 3)
      return 0.4 * ProfitTargetUSD;
   else if(sameDirectionCount == 4)
      return 0.5 * ProfitTargetUSD;
   else if(sameDirectionCount == 5)
      return 0.8 * ProfitTargetUSD;
   else if(sameDirectionCount >= 6 && sameDirectionCount <= 9)
      return 1.0 * ProfitTargetUSD;
   else if(sameDirectionCount >= 10 && sameDirectionCount < 20)
      return 2.0 * ProfitTargetUSD;
   else if(sameDirectionCount >= 20 && sameDirectionCount < 25)
      return 3.0 * ProfitTargetUSD;
   else if(sameDirectionCount >= 25)
      return 4.0 * ProfitTargetUSD;
      
   return 0;
}

//+------------------------------------------------------------------+
//| Check volume filter condition                                    |
//+------------------------------------------------------------------+
bool CheckVolumeFilter()
{
   if(!EnableVolumeFilter) return true;
   
   double currentVolume = (double)iVolume(currentSymbol, _Period, 0);
   if(currentVolume >= VolumeThreshold) return true;
   
   Log(StringFormat("Volume filter blocking trade: %.2f < %.2f", 
                   currentVolume, VolumeThreshold));
   return false;
}

//+------------------------------------------------------------------+
//| Check if EA is in halt period                                    |
//+------------------------------------------------------------------+
bool IsInHaltPeriod()
{
   if(HaltPeriodSeconds <= 0) return false;
   
   if(inHaltPeriod && (TimeCurrent() >= lastTradeCloseTime + HaltPeriodSeconds)) {
      inHaltPeriod = false;
      Log("Halt period ended");
   }
   
   return inHaltPeriod;
}

//+------------------------------------------------------------------+
//| Strict consecutive candles check                                 |
//+------------------------------------------------------------------+
bool CheckStrictConsecutiveCandles(int &dir)
{
   MqlRates rates[];
   if(CopyRates(currentSymbol, _Period, 1, ConsecutiveCandles, rates) < ConsecutiveCandles) {
      Log("Insufficient data for candle check");
      return false;
   }
   
   bool allBullish = true;
   bool allBearish = true;
   
   for(int i = 0; i < ConsecutiveCandles; i++) {
      if(rates[i].close <= rates[i].open) allBullish = false;
      if(rates[i].close >= rates[i].open) allBearish = false;
   }

   if(allBullish) {
      Log("Found valid bullish candle pattern - BUY signal");
      dir = 1; 
      return true;
   }
   if(allBearish) {
      Log("Found valid bearish candle pattern - SELL signal");
      dir = -1; 
      return true;
   }
   Log("No valid consecutive candle pattern found");
   return false;
}

//+------------------------------------------------------------------+
//| Enhanced Hedge Logic with Manual Pips and Candle Close Execution |
//+------------------------------------------------------------------+
void ManageHedging()
{
    if(!EnableHedges || !EnableHedging) return;
    if(sameDirectionCount == 0) return;

    static datetime lastCandleTime = 0;
    static bool pendingHedge = false;
    static double pendingTriggerPrice = 0;
    static int pendingHedgeIndex = 0;

    datetime currentCandleTime = iTime(currentSymbol, PERIOD_M1, 0);
    double currentPrice = SymbolInfoDouble(currentSymbol, (direction == 1) ? SYMBOL_BID : SYMBOL_ASK);
    double point = GetCurrentPoint();

    // Get required drawdown from manual pips array
    int requiredDrawdown = MaxHedgeDrawdownPips;
    if(useManualDrawdown && ArraySize(manualDrawdownPips) > 0)
    {
        int hedgeIndex = sameDirectionCount - 1;
        if(hedgeIndex < ArraySize(manualDrawdownPips))
            requiredDrawdown = manualDrawdownPips[hedgeIndex];
        else
            requiredDrawdown = manualDrawdownPips[ArraySize(manualDrawdownPips)-1];
    }

    // Calculate trigger price for current hedge level
    double triggerPrice = (direction == 1) ? 
        lastMainEntryPrice - (requiredDrawdown * PIP * point) : 
        lastMainEntryPrice + (requiredDrawdown * PIP * point);

    // Check new candle
    if(currentCandleTime != lastCandleTime)
    {
        // Get previous candle's close price
        double previousClose = iClose(currentSymbol, PERIOD_M1, 1);
        double drawdownPips = MathAbs(lastMainEntryPrice - previousClose) / (point * PIP);
        
        // Check if previous candle closed beyond required level
        if((direction == 1 && previousClose <= triggerPrice) || 
           (direction == -1 && previousClose >= triggerPrice))
        {
            pendingHedge = true;
            pendingTriggerPrice = triggerPrice;
            pendingHedgeIndex = sameDirectionCount;
            
            Log(StringFormat("Hedge #%d triggered: Candle closed at %.5f (%.1f pips drawdown, required: %d pips)",
                sameDirectionCount, previousClose, drawdownPips, requiredDrawdown));
        }
        lastCandleTime = currentCandleTime;
    }

    // Execute pending hedge if price reaches trigger level
    if(pendingHedge && pendingHedgeIndex == sameDirectionCount)
    {
        bool priceReached = (direction == 1) ? 
            (currentPrice <= pendingTriggerPrice) : 
            (currentPrice >= pendingTriggerPrice);

        if(priceReached)
        {
            // Open hedge position (existing lot size calculation logic)
            double lot = 0;
            if(ArraySize(lotSequence) > 0 && sameDirectionCount-1 < ArraySize(lotSequence))
                lot = lotSequence[sameDirectionCount-1];
            else if(ArraySize(lotSequence) > 0)
                lot = lotSequence[ArraySize(lotSequence)-1];
            else
                lot = NormalizeDouble(InitialLotSize * MathPow(LotMultiplier, sameDirectionCount-1), 2);

            if(trade.PositionOpen(currentSymbol, direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
                lot, currentPrice, 0, 0, HEDGE_COMMENT))
            {
                Log(StringFormat("Hedge #%d opened at %.5f (%d pips drawdown)",
                    sameDirectionCount, currentPrice, requiredDrawdown));
                
                sameDirectionCount++;
                lastMainEntryPrice = currentPrice;
                pendingHedge = false;
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Open Alternate Hedge Trade                                       |
//+------------------------------------------------------------------+
void OpenAlternateHedge()
{
   datetime currentBarTime = iTime(currentSymbol, _Period, 0);
   
   if(lastAlternateHedgeTime == currentBarTime) return;
   
   double currentPrice = SymbolInfoDouble(currentSymbol, (direction == 1) ? SYMBOL_ASK : SYMBOL_BID);
   double point = GetCurrentPoint();
   
   if(!AllowReentryAtSamePrice) {
      for(int i = 0; i < ArraySize(alternateHedgePrices); i++) {
         if(MathAbs(alternateHedgePrices[i] - currentPrice) < (0.5 * PIP * point)) {
            Log(StringFormat("Skipping alternate hedge at %.5f - same as previous entry", currentPrice));
            return;
         }
      }
   }
   
   double tpPrice = 0;
   if(AlternateHedgeTPPips > 0) {
      if(direction == 1) {
         tpPrice = currentPrice + AlternateHedgeTPPips * PIP * point;
      } else {
         tpPrice = currentPrice - AlternateHedgeTPPips * PIP * point;
      }
   }
   
   trade.SetExpertMagicNumber(MagicNumber);
   if(trade.PositionOpen(currentSymbol, direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
                      AlternateLotSize, currentPrice, 0, tpPrice, ALT_COMMENT))
   {
      ArrayResize(alternateHedgePrices, ArraySize(alternateHedgePrices)+1);
      alternateHedgePrices[ArraySize(alternateHedgePrices)-1] = currentPrice;
      
      Log(StringFormat("Opened Alternate Hedge: %s %.2f lots @ %.5f (TP: %.5f, After hedge #%d)",
                      (direction == 1) ? "BUY" : "SELL",
                      AlternateLotSize,
                      currentPrice,
                      tpPrice,
                      sameDirectionCount-1));
      lastAlternateHedgeTime = currentBarTime;
      dailyTrades++;
      currentStatus = StringFormat("Opened Alternate Hedge @ %.5f", currentPrice);
      Log("Status: " + currentStatus);
      
      AddHedgeToTracking(currentPrice, AlternateLotSize, direction, ALT_COMMENT);
   }
   else {
      int error = GetLastError();
      Log(StringFormat("Failed to open alternate hedge! Error: %d", error));
   }
}

//+------------------------------------------------------------------+
//| Add hedge position to tracking array                             |
//+------------------------------------------------------------------+
void AddHedgeToTracking(double entryPrice, double lotSize, int direction, string comment)
{
   HedgePosition hedge;
   hedge.entryPrice = entryPrice;
   hedge.lotSize = lotSize;
   hedge.direction = direction;
   hedge.closedInProfit = false;
   hedge.closeTime = 0;
   hedge.comment = comment;
   
   int size = ArraySize(closedHedges);
   ArrayResize(closedHedges, size + 1);
   closedHedges[size] = hedge;
   
   Log(StringFormat("Added hedge to tracking: %.2f lots @ %.5f (%s)", 
                   lotSize, entryPrice, comment));
}

//+------------------------------------------------------------------+
//| Reverse Hedge Logic (Fixed)                                      |
//+------------------------------------------------------------------+
void ManageReverseHedging()
{
   if(sameDirectionCount < ReverseHedgeAfterTrades) return;
   if(reverseTradeCount >= MaxReverseTrades) return;
   
   datetime currentBarTime = iTime(currentSymbol, _Period, 0);
   double point = GetCurrentPoint();
   
   if(lastReverseHedgeTime == currentBarTime) return;

   double basePrice = (reverseTradeCount == 0) ? lastMainEntryPrice : lastReverseEntryPrice;
   
   double currentPrice = SymbolInfoDouble(currentSymbol, (direction == 1) ? SYMBOL_BID : SYMBOL_ASK);
   
   double priceDeviation = MathAbs(basePrice - currentPrice) / (point * PIP);
   
   bool priceCondition = false;
   if(direction == 1) {
      priceCondition = (currentPrice < basePrice);
   } else {
      priceCondition = (currentPrice > basePrice);
   }

   if(priceDeviation >= ReverseHedgeTriggerPips && priceCondition)
   {
      double lot = (reverseTradeCount < ArraySize(reverseLotSequence)) 
                  ? reverseLotSequence[reverseTradeCount] 
                  : NormalizeDouble(ReverseInitialLotSize * MathPow(ReverseLotMultiplier, reverseTradeCount), 2);
      
      ENUM_ORDER_TYPE tradeType = (direction == 1) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
      
      double tpPrice = 0;
      if(ReverseHedgeTPPips > 0) {
         if(tradeType == ORDER_TYPE_BUY) {
            tpPrice = currentPrice + ReverseHedgeTPPips * PIP * point;
         } else {
            tpPrice = currentPrice - ReverseHedgeTPPips * PIP * point;
         }
      }
      
      trade.SetExpertMagicNumber(MagicNumber);
      if(trade.PositionOpen(currentSymbol, tradeType, lot, currentPrice, 0, tpPrice, REVERSE_COMMENT))
      {
         reverseTradeCount++;
         lastReverseEntryPrice = currentPrice;
         lastReverseHedgeTime = currentBarTime;
         dailyTrades++;
         
         Log(StringFormat("Opened REVERSE HEDGE #%d: %s %.2f lots @ %.5f (Deviation: %.1f pips)",
                         reverseTradeCount,
                         EnumToString(tradeType),
                         lot,
                         currentPrice,
                         priceDeviation));
      }
      else
      {
         int error = GetLastError();
         string errDesc = ErrorDescription(error);
         Log(StringFormat("Reverse hedge FAILED! Dir: %s, Lot: %.2f, Price: %.5f, Error: %d - %s",
                         EnumToString(tradeType),
                         lot,
                         currentPrice,
                         error,
                         errDesc));
      }
   }
}

//+------------------------------------------------------------------+
//| Enhanced manual trade detection (FIXED)                          |
//+------------------------------------------------------------------+
void CheckManualTrades()
{
    if(!IncorporateManualTrades) return;
    
    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket <= 0) continue;
        
        long positionMagic = PositionGetInteger(POSITION_MAGIC);
        string comment = PositionGetString(POSITION_COMMENT);
        
        if(positionMagic == MagicNumber && comment == "")
        {
            manualTradeDetected = true;
            
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double lotSize = PositionGetDouble(POSITION_VOLUME);
            
            if(posType == POSITION_TYPE_BUY)
            {
                direction = 1;
                Log("Detected manual BUY trade: " + DoubleToString(lotSize, 2) + 
                    " lots @ " + DoubleToString(entryPrice, 5));
            }
            else if(posType == POSITION_TYPE_SELL)
            {
                direction = -1;
                Log("Detected manual SELL trade: " + DoubleToString(lotSize, 2) + 
                    " lots @ " + DoubleToString(entryPrice, 5));
            }
            
            sameDirectionCount = 1;
            lastMainEntryPrice = entryPrice;
            initialEntryPrice = entryPrice;
            initialBarTime = iTime(currentSymbol, _Period, 0);
            initialTradeOpenTime = TimeCurrent();
            
            double currentSL = PositionGetDouble(POSITION_SL);
            double currentTP = PositionGetDouble(POSITION_TP);
            trade.PositionModify(ticket, currentSL, currentTP);
            
            SendStatusNotification("Incorporated manual trade: " + 
                                  (posType == POSITION_TYPE_BUY ? "BUY" : "SELL") + 
                                  " " + DoubleToString(lotSize, 2) + " lots @ " + 
                                  DoubleToString(entryPrice, 5));
            break;
        }
        else if(positionMagic != MagicNumber && IncorporateManualTrades)
        {
            manualTradeDetected = true;
            
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double lotSize = PositionGetDouble(POSITION_VOLUME);
            
            if(posType == POSITION_TYPE_BUY)
            {
                direction = 1;
                Log("Detected external manual BUY trade: " + DoubleToString(lotSize, 2) + 
                    " lots @ " + DoubleToString(entryPrice, 5));
            }
            else if(posType == POSITION_TYPE_SELL)
            {
                direction = -1;
                Log("Detected external manual SELL trade: " + DoubleToString(lotSize, 2) + 
                    " lots @ " + DoubleToString(entryPrice, 5));
            }
            
            sameDirectionCount = 1;
            lastMainEntryPrice = entryPrice;
            initialEntryPrice = entryPrice;
            initialBarTime = iTime(currentSymbol, _Period, 0);
            initialTradeOpenTime = TimeCurrent();
            
            SendStatusNotification("Detected external manual trade: " + 
                                  (posType == POSITION_TYPE_BUY ? "BUY" : "SELL") + 
                                  " " + DoubleToString(lotSize, 2) + " lots @ " + 
                                  DoubleToString(entryPrice, 5));
            break;
        }
    }
}

//+------------------------------------------------------------------+
//| Count manual trades being managed by EA                          |
//+------------------------------------------------------------------+
int CountManualTrades()
{
    int count = 0;
    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket <= 0) continue;
        
        if(PositionGetInteger(POSITION_MAGIC) == MagicNumber && 
           PositionGetString(POSITION_COMMENT) == MANUAL_COMMENT)
        {
            count++;
        }
    }
    return count;
}

//+------------------------------------------------------------------+
//| Count EA trades only (including managed manual trades)           |
//+------------------------------------------------------------------+
int CountOpenEATrades()
{
   int count = 0;
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
      {
         string comment = PositionGetString(POSITION_COMMENT);
         if(comment == INITIAL_COMMENT || 
            comment == HEDGE_COMMENT || 
            comment == ALT_COMMENT || 
            comment == REVERSE_COMMENT ||
            comment == MANUAL_COMMENT)
         {
            count++;
         }
      }
      else if(IncorporateManualTrades)
      {
         count++;
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Get total unrealized profit for EA trades only                   |
//+------------------------------------------------------------------+
double GetTotalEAUnrealizedProfit()
{
   double profit = 0;
   for(int i = PositionsTotal()-1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
         profit += PositionGetDouble(POSITION_PROFIT);
      }
      else if(IncorporateManualTrades) {
         profit += PositionGetDouble(POSITION_PROFIT);
      }
   }
   return profit;
}

//+------------------------------------------------------------------+
//| Close all EA trades only (with halt period activation)           |
//+------------------------------------------------------------------+
bool CloseAllEATrades()
{
   int closeCount = 0;
   double totalProfit = 0;
   
   for(int i = PositionsTotal()-1; i >=0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
         double positionProfit = PositionGetDouble(POSITION_PROFIT);
         totalProfit += positionProfit;
         
         if(trade.PositionClose(ticket)) {
            closeCount++;
            Log(StringFormat("Closed EA position: Ticket=%d, Profit=%.2f", ticket, positionProfit));
         }
         else {
            Log(StringFormat("Failed to close EA position! Ticket=%d, Error=%d", ticket, GetLastError()));
         }
      }
      else if(IncorporateManualTrades) {
         double positionProfit = PositionGetDouble(POSITION_PROFIT);
         totalProfit += positionProfit;
         
         if(trade.PositionClose(ticket)) {
            closeCount++;
            Log(StringFormat("Closed manual position: Ticket=%d, Profit=%.2f", ticket, positionProfit));
         }
         else {
            Log(StringFormat("Failed to close manual position! Ticket=%d, Error=%d", ticket, GetLastError()));
         }
      }
   }
   
   if(closeCount > 0) {
      Log(StringFormat("Closed %d positions. Total profit: %.2f", closeCount, totalProfit));
      
      ResetEAState();
      
      lastTradeCloseTime = TimeCurrent();
      inHaltPeriod = true;
      Log(StringFormat("%d second halt period activated", HaltPeriodSeconds));
      
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Remove TP from initial EA position (FIXED)                       |
//+------------------------------------------------------------------+
void RemoveInitialPositionTP()
{
   ulong initialTicket = 0;
   datetime earliestTime = D'3000.01.01';
   
   for(int i = PositionsTotal()-1; i >=0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      datetime posTime = (datetime)PositionGetInteger(POSITION_TIME);
      if(posTime < earliestTime) {
         earliestTime = posTime;
         initialTicket = ticket;
      }
   }
   
   if(initialTicket == 0) return;
   
   double currentSL = PositionGetDouble(POSITION_SL);
   trade.PositionModify(initialTicket, currentSL, 0);
}

//+------------------------------------------------------------------+
//| Check time-based exit conditions                                 |
//+------------------------------------------------------------------+
void CheckTimeExit()
{
   if(!EnableTimeExit || timeExitTriggered) return;
   
   if(sameDirectionCount >= 2 && initialTradeOpenTime > 0) {
      datetime referenceTime = (firstHedgeOpenTime > 0) ? firstHedgeOpenTime : initialTradeOpenTime;
      double hoursElapsed = (TimeCurrent() - referenceTime) / 3600.0;
      
      if(hoursElapsed >= MaxTimeForInitialHedge) {
         double totalProfit = GetTotalEAUnrealizedProfit();
         if(MathAbs(totalProfit) <= BreakevenThreshold) {
            Log(StringFormat("Time exit triggered: %.2f hours elapsed (max: %.2f) and near breakeven: %.2f",
                            hoursElapsed, MaxTimeForInitialHedge, totalProfit));
            timeExitTriggered = true;
            
            if(CloseAllEATrades()) {
               currentStatus = "Time-based exit activated - all positions closed";
               Log("Status: " + currentStatus);
               SendStatusNotification(currentStatus);
            }
         }
         else {
            Log(StringFormat("Time condition met (%.2f hours) but not near breakeven: %.2f", 
                            hoursElapsed, totalProfit));
         }
      }
      else {
         static datetime lastLogTime = 0;
         if(TimeCurrent() - lastLogTime >= 30) {
            lastLogTime = TimeCurrent();
            Log(StringFormat("Time exit monitoring: %.2f/%.2f hours elapsed", 
                            hoursElapsed, MaxTimeForInitialHedge));
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Check profit target and cooldown                                 |
//+------------------------------------------------------------------+
void CheckProfitTarget()
{
   if(!EnableProfitTarget || ProfitTargetFixed <= 0) return;
   
   if(cooldownStartTime > 0) {
      double hoursInCooldown = (TimeCurrent() - cooldownStartTime) / 3600.0;
      if(hoursInCooldown >= ProfitTargetCooldownHours) {
         cooldownStartTime = 0;
         profitTargetReached = false;
         Log("Profit target cooldown period ended");
      }
      else {
         int minutesLeft = (int)((ProfitTargetCooldownHours * 3600) - (TimeCurrent() - cooldownStartTime)) / 60;
         currentStatus = StringFormat("In cooldown: %d minutes remaining", minutesLeft);
         if(TimeCurrent() % 30 == 0) {
            Log("Status: " + currentStatus);
         }
         return;
      }
   }
   
   if(!profitTargetReached) {
      double currentProfit = CalculateTotalProfitSinceReset();
      
      if(currentProfit >= ProfitTargetFixed) {
         Log(StringFormat("Profit target reached: %.2f/%.2f", 
                         currentProfit, ProfitTargetFixed));
         
         if(CloseAllEATrades()) {
            profitTargetReached = true;
            cooldownStartTime = TimeCurrent();
            currentStatus = "Profit target reached - all positions closed";
            Log("Status: " + currentStatus);
            SendStatusNotification(currentStatus);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Track manually closed hedge positions                            |
//+------------------------------------------------------------------+
void TrackManuallyClosedHedges()
{
   static int previousEATradeCount = 0;
   int currentEATradeCount = CountOpenEATrades();
   
   if(previousEATradeCount > currentEATradeCount) 
   {
      for(int i = 0; i < ArraySize(closedHedges); i++) 
      {
         bool stillExists = false;
         for(int j = PositionsTotal()-1; j >= 0; j--) 
         {
            ulong ticket = PositionGetTicket(j);
            if(ticket <= 0) continue;
            
            if(PositionGetInteger(POSITION_MAGIC) == MagicNumber &&
               PositionGetDouble(POSITION_PRICE_OPEN) == closedHedges[i].entryPrice &&
               PositionGetDouble(POSITION_VOLUME) == closedHedges[i].lotSize &&
               PositionGetInteger(POSITION_TYPE) == (closedHedges[i].direction == 1 ? POSITION_TYPE_BUY : POSITION_TYPE_SELL)) 
            {
               stillExists = true;
               break;
            }
         }
         
        if(!stillExists) 
        {
            HistorySelect(0, TimeCurrent());
            int totalDeals = HistoryDealsTotal();
            double profit = 0;
            datetime closeTime = 0;
            
            for(int k = 0; k < totalDeals; k++) 
            {
               ulong ticket = HistoryDealGetTicket(k);
               if(HistoryDealGetInteger(ticket, DEAL_ENTRY) != DEAL_ENTRY_OUT) continue;
               
               if(HistoryDealGetDouble(ticket, DEAL_PRICE) == closedHedges[i].entryPrice &&
                  HistoryDealGetDouble(ticket, DEAL_VOLUME) == closedHedges[i].lotSize) 
               {
                  profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
                  closeTime = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
                  break;
               }
            }
            
            if(profit > 0) 
            {
               int size = ArraySize(manuallyClosedHedges);
               ArrayResize(manuallyClosedHedges, size + 1);
               manuallyClosedHedges[size] = closedHedges[i];
               manuallyClosedHedges[size].closedInProfit = true;
               manuallyClosedHedges[size].closeTime = closeTime;
               
               Log(StringFormat("Hedge position closed in profit: %.2f lots @ %.5f, Profit: %.2f",
                               closedHedges[i].lotSize, closedHedges[i].entryPrice, profit));
            }
            
            ArrayRemove(closedHedges, i, 1);
            i--;
         }
      }
   }
   
   previousEATradeCount = currentEATradeCount;
}

//+------------------------------------------------------------------+
//| Re-open manually closed hedge positions                          |
//+------------------------------------------------------------------+
void ReopenManuallyClosedHedges()
{
   double point = GetCurrentPoint();
   double currentPrice = SymbolInfoDouble(currentSymbol, (direction == 1) ? SYMBOL_BID : SYMBOL_ASK);
   
   for(int i = 0; i < ArraySize(manuallyClosedHedges); i++) 
   {
      if(MathAbs(currentPrice - manuallyClosedHedges[i].entryPrice) <= 5 * point * PIP) 
      {
         if(TimeCurrent() - manuallyClosedHedges[i].closeTime >= 60) 
         {
            if(CountOpenEATrades() < MaxTrades) 
            {
               trade.SetExpertMagicNumber(MagicNumber);
               if(trade.PositionOpen(currentSymbol, manuallyClosedHedges[i].direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
                                  manuallyClosedHedges[i].lotSize, currentPrice, 0, 0, HEDGE_COMMENT))
               {
                  Log(StringFormat("Re-opened manually closed hedge: %s %.2f lots @ %.5f",
                                  (manuallyClosedHedges[i].direction == 1) ? "BUY" : "SELL",
                                  manuallyClosedHedges[i].lotSize,
                                  currentPrice));
                  
                  AddHedgeToTracking(currentPrice, manuallyClosedHedges[i].lotSize, 
                                    manuallyClosedHedges[i].direction, HEDGE_COMMENT);
                  
                  ArrayRemove(manuallyClosedHedges, i, 1);
                  i--;
               }
            }
            else 
            {
               Log("Cannot reopen hedge: Maximum trades reached");
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Update hedge positions array for time exit tracking              |
//+------------------------------------------------------------------+
void UpdateHedgePositionsArray()
{
   ArrayResize(hedgePositions, 0);
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      string comment = PositionGetString(POSITION_COMMENT);
      if(comment != HEDGE_COMMENT && comment != ALT_COMMENT) continue;
      
      HedgeInfo hi;
      hi.ticket = ticket;
      hi.openTime = (datetime)PositionGetInteger(POSITION_TIME);
      hi.openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      hi.lotSize = PositionGetDouble(POSITION_VOLUME);
      hi.direction = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ? 1 : -1;
      hi.comment = comment;
      
      int size = ArraySize(hedgePositions);
      ArrayResize(hedgePositions, size + 1);
      hedgePositions[size] = hi;
   }
}

//+------------------------------------------------------------------+
//| Check hedge time exit conditions                                 |
//+------------------------------------------------------------------+
void CheckHedgeTimeExit()
{
   if(!EnableHedgeTimeExit) return;
   
   for(int i = 0; i < ArraySize(hedgePositions); i++)
   {
      ulong ticket = hedgePositions[i].ticket;
      double hoursOpen = (TimeCurrent() - hedgePositions[i].openTime) / 3600.0;
      
      if(hoursOpen >= MaxHedgeHours)
      {
         double profit = PositionGetDouble(POSITION_PROFIT);
         
         bool shouldClose = !CloseOnlyProfitableHedges || (CloseOnlyProfitableHedges && profit >= HedgeTimeExitThreshold);
         
         if(shouldClose)
         {
            if(trade.PositionClose(ticket))
            {
               Log(StringFormat("Time exit closed hedge: Ticket=%d, Hours=%.2f, Profit=%.2f",
                               ticket, hoursOpen, profit));
               
               AddHedgeToTracking(hedgePositions[i].openPrice, 
                                 hedgePositions[i].lotSize,
                                 hedgePositions[i].direction,
                                 hedgePositions[i].comment);
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Reopen closed hedges when price returns to entry level           |
//+------------------------------------------------------------------+
void ReopenClosedHedges()
{
   double point = GetCurrentPoint();
   double currentPrice = SymbolInfoDouble(currentSymbol, (direction == 1) ? SYMBOL_BID : SYMBOL_ASK);
   
   for(int i = 0; i < ArraySize(closedHedges); i++)
   {
      if(MathAbs(currentPrice - closedHedges[i].entryPrice) <= 2 * point * PIP)
      {
         if(CountOpenEATrades() < MaxTrades)
         {
            double newLotSize = closedHedges[i].lotSize * ReopenLotMultiplier;
            newLotSize = NormalizeDouble(newLotSize, 2);
            
            Log(StringFormat("Price returned to hedge level: %.5f (original: %.5f)", 
                           currentPrice, closedHedges[i].entryPrice));
            
            trade.SetExpertMagicNumber(MagicNumber);
            if(trade.PositionOpen(currentSymbol, 
                                closedHedges[i].direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
                                newLotSize, 
                                currentPrice, 
                                0, 0, 
                                closedHedges[i].comment))
            {
               Log(StringFormat("Reopened %s hedge: %.2f lots @ %.5f (original: %.2f lots @ %.5f)",
                               closedHedges[i].comment,
                               newLotSize,
                               currentPrice,
                               closedHedges[i].lotSize,
                               closedHedges[i].entryPrice));
               
               closedHedges[i].lotSize = newLotSize;
               closedHedges[i].entryPrice = currentPrice;
               
               if(EnableReopenTrailing)
               {
                  Log(StringFormat("Trailing enabled for reopened hedge. Will activate at $%.2f profit", 
                                  ReopenTrailingProfit));
               }
            }
            else 
            {
               int error = GetLastError();
               Log(StringFormat("Failed to reopen hedge! Error: %d", error));
            }
         }
         else 
         {
            Log("Cannot reopen hedge: Maximum trades reached");
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Manage trailing for reopened hedges                              |
//+------------------------------------------------------------------+
void ManageReopenTrailing()
{
   if(!EnableReopenTrailing) return;
   
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      string comment = PositionGetString(POSITION_COMMENT);
      if(comment != HEDGE_COMMENT && comment != ALT_COMMENT) continue;
      
      double profit = PositionGetDouble(POSITION_PROFIT);
      double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      
      if(profit >= ReopenTrailingProfit)
      {
         double newSL = 0;
         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
         {
            newSL = currentPrice - (ReopenTrailingDistance / (PositionGetDouble(POSITION_VOLUME) * 
                   SymbolInfoDouble(currentSymbol, SYMBOL_TRADE_TICK_VALUE) / Point()));
         }
         else
         {
            newSL = currentPrice + (ReopenTrailingDistance / (PositionGetDouble(POSITION_VOLUME) * 
                   SymbolInfoDouble(currentSymbol, SYMBOL_TRADE_TICK_VALUE) / Point()));
         }
         
         newSL = NormalizeDouble(newSL, _Digits);
         
         if((PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && newSL > currentSL) ||
            (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && newSL < currentSL))
         {
            trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
            Log(StringFormat("Updated trailing SL for reopened hedge: Ticket=%d, New SL=%.5f", ticket, newSL));
         }
      }
   }
}

//+------------------------------------------------------------------+
//| OnTrade function with state reset on manual close                |
//+------------------------------------------------------------------+
void OnTrade()
{
   static int previousEATradeCount = 0;
   int currentEATradeCount = CountOpenEATrades();

   if(currentEATradeCount == 0) {
      ArrayResize(alternateHedgePrices, 0);
   }

   TrackManuallyClosedHedges();

   if(previousEATradeCount > 0 && currentEATradeCount == 0 && !inHaltPeriod) {
      ResetEAState();
      Log("State reset due to manual close of all trades");
   }

   previousEATradeCount = currentEATradeCount;
}

//+------------------------------------------------------------------+
//| Display information on chart function                            |
//+------------------------------------------------------------------+
void DisplayInfoOnChart()
{
   if(!EnableChartDisplay) return;
   
   string displayText = "";
   string newLine = "\n";
   
   displayText += "=== Reliable EA Status ===" + newLine;
   displayText += "Status: " + currentStatus + newLine;
   displayText += "Balance: $" + DoubleToString(accountInfo.Balance(), 2) + newLine;
   displayText += "Equity: $" + DoubleToString(accountInfo.Equity(), 2) + newLine;
   displayText += "Total P/L: $" + DoubleToString(CalculateTotalProfitSinceReset(), 2) + newLine;
   displayText += "Open Trades: " + IntegerToString(CountOpenEATrades()) + newLine;
   displayText += "Main Sequence: " + IntegerToString(sameDirectionCount) + newLine;
   displayText += "Reverse Hedges: " + IntegerToString(reverseTradeCount) + newLine;
   displayText += "Max Daily Drawdown: " + DoubleToString(maxDailyDrawdown, 1) + "%" + newLine;
   displayText += "Win Rate: " + DoubleToString(winRate, 1) + "%" + newLine;
   displayText += "Risk/Reward: " + DoubleToString(riskRewardRatio, 2) + newLine;
   
   if(EnableProfitTarget) {
      displayText += "Profit Target: $" + DoubleToString(ProfitTargetFixed, 2) + newLine;
      
      if(cooldownStartTime > 0) {
         int minutesLeft = (int)((ProfitTargetCooldownHours * 3600) - (TimeCurrent() - cooldownStartTime)) / 60;
         displayText += "Cooldown: " + IntegerToString(minutesLeft) + " minutes left" + newLine;
      }
   }
   
   Comment(displayText);
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   currentSymbol = (StringLen(TradeSymbol) > 0) ? TradeSymbol : _Symbol;
   
   Log("Status: EA initialization started for " + currentSymbol);
   highestBalance = accountInfo.Balance();
   sameDirectionCount = 0;
   reverseTradeCount = 0;
   lastTradeCloseTime = 0;
   inHaltPeriod = false;
   initialBarTime = 0;
   ArrayResize(alternateHedgePrices, 0);
   inRecoveryMode = false;
   dailyProfit = 0;
   dailyTrades = 0;
   maxDailyDrawdown = 0;
   winRate = 0;
   riskRewardRatio = 0;
   lastDailyReset = 0;
   manualTradeDetected = false;
   currentRequiredDrawdown = MaxHedgeDrawdownPips;
   groupTrailingLevel = 0;
   peakGroupProfit = 0;
   trailingActive = false;
   activationLevel = 0;
   peakProfit = 0;
   initialTradeOpenTime = 0;
   firstHedgeOpenTime = 0;
   timeExitTriggered = false;
   
   totalProfitSinceReset = 0;
   profitTargetReached = false;
   cooldownStartTime = 0;
   
   ArrayResize(closedHedges, 0);
   ArrayResize(manuallyClosedHedges, 0);
   ArrayResize(hedgePositions, 0);
   
   trade.SetDeviationInPoints(MaxSlippagePips * PIP);
   
   if(UseEMAFilter) {
      emaHandle = iMA(currentSymbol, _Period, EMA_Period, 0, MODE_EMA, PRICE_CLOSE);
      if(emaHandle == INVALID_HANDLE) {
         Log("Error: Failed to create EMA indicator!");
         return(INIT_FAILED);
      }
   }
   
   if(UseRSIFilter) {
      rsiHandle = iRSI(currentSymbol, _Period, RSI_Period, PRICE_CLOSE);
      if(rsiHandle == INVALID_HANDLE) {
         Log("Error: Failed to create RSI indicator!");
         return(INIT_FAILED);
      }
   }
   
   if(UseMACDFilter) {
      macdHandle = iMACD(currentSymbol, _Period, MACDFast, MACDSlow, MACDSignal, PRICE_CLOSE);
      if(macdHandle == INVALID_HANDLE) {
         Log("Error: Failed to create MACD indicator!");
         return(INIT_FAILED);
      }
   }
   
   if(StringLen(CustomLotSizes) > 0) {
      useCustomLots = true;
      StringToLotArray(CustomLotSizes);
      Log("Status: Using custom lot sequence");
   }
   else {
      useCustomLots = false;
      GenerateLotSequence();
      Log("Status: Using multiplier-generated lot sequence");
   }
   
   GenerateReverseLotSequence();
   
   if(StringLen(HedgeDrawdownPips) > 0) {
      useManualDrawdown = true;
      string temp[];
      int count = StringSplit(HedgeDrawdownPips, ',', temp);
      ArrayResize(manualDrawdownPips, count);
      for(int i = 0; i < count; i++) {
         manualDrawdownPips[i] = (int)StringToInteger(temp[i]);
      }
      Log(StringFormat("Manual drawdown sequence parsed: %d entries", count));
      
      if(count > 0) currentRequiredDrawdown = manualDrawdownPips[0];
   }
   
   if(StringLen(CustomProfitTargets) > 0) {
      string temp[];
      int count = StringSplit(CustomProfitTargets, ',', temp);
      ArrayResize(customProfitTargets, count);
      for(int i = 0; i < count; i++) {
         customProfitTargets[i] = StringToDouble(temp[i]);
      }
      Log(StringFormat("Custom profit targets parsed: %d entries", count));
      
      string targetsStr = "Custom profit targets: ";
      for(int i = 0; i < ArraySize(customProfitTargets); i++) {
         targetsStr += DoubleToString(customProfitTargets[i], 2) + " ";
      }
      Log(targetsStr);
   }
   
   if(IncorporateManualTrades) {
      CheckManualTrades();
   }
   
   if(StringLen(NotificationPhoneNumber) > 5) {
      Log("SMS alerts enabled for: Reliable" + NotificationPhoneNumber);
   }
   
   UpdateDailyStats();
   
   Log("Status: EA initialization complete - Waiting for market conditions");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Comment("");
   if(emaHandle != INVALID_HANDLE) IndicatorRelease(emaHandle);
   if(rsiHandle != INVALID_HANDLE) IndicatorRelease(rsiHandle);
   if(macdHandle != INVALID_HANDLE) IndicatorRelease(macdHandle);
   Log("EA deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function with enhanced logging                       |
//+------------------------------------------------------------------+
void OnTick()
{
   static int tickCount = 0;
   tickCount++;
   
   if(IncorporateManualTrades) {
      CheckManualTrades();
   }
   
   UpdateDailyStats();
   CalculatePerformanceMetrics();
   
   CheckProfitTarget();
   
   DisplayInfoOnChart();
   
   UpdateHedgePositionsArray();
   
   CheckHedgeTimeExit();
   
   ReopenClosedHedges();
   
   ManageReopenTrailing();
   
   if(cooldownStartTime > 0) {
      if(tickCount % 30 == 0) {
         int minutesLeft = (int)((ProfitTargetCooldownHours * 3600) - (TimeCurrent() - cooldownStartTime)) / 60;
         currentStatus = StringFormat("In cooldown: %d minutes remaining", minutesLeft);
         Log("Status: " + currentStatus);
      }
      return;
   }
   
   if(EnableNewsFilter && IsNewsEvent()) {
      currentStatus = "High-impact news - trading paused";
      if(tickCount % 30 == 0) Log("Status: Trading paused due to news event");
      return;
   }
   
   CheckRecoveryMode();
   
   ManageAltHedgeTrailing();
   
   if(TimeCurrent() - lastManualCloseCheck >= 5) 
   {
      TrackManuallyClosedHedges();
      lastManualCloseCheck = TimeCurrent();
   }
   
   ReopenManuallyClosedHedges();
   
   if(!EnableStrategy) {
      if(tickCount % 100 == 0) Log("Status: Strategy disabled - EA is idle");
      return;
   }
   
   if(emergencyStopTriggered) {
      if(tickCount % 50 == 0) Log("Status: EMERGENCY STOP ACTIVE - all trading disabled");
      return;
   }
   
   if(CheckEmergencyStop()) return;
   
   if(IsInHaltPeriod()) {
      if(tickCount % 10 == 0) {
         int secondsLeft = (int)(lastTradeCloseTime + HaltPeriodSeconds - TimeCurrent());
         currentStatus = "In halt period: " + IntegerToString(secondsLeft) + "s remaining";
      }
      return;
   }
   
   double currentBalance = accountInfo.Balance();
   if(currentBalance > highestBalance) {
      highestBalance = currentBalance;
      Log(StringFormat("New high balance: %.2f", highestBalance));
   }
   
   if(EnableTimeFilter && !IsTradingTime() && CountOpenEATrades() == 0) {
      if(tickCount % 30 == 0) {
         currentStatus = "Outside trading session";
         Log("Status: " + currentStatus);
      }
      return;
   }

   int totalEATrades = CountOpenEATrades();
   int manualTrades = CountManualTrades();
   bool hasManualTrade = manualTradeDetected;
   double totalProfit = GetTotalEAUnrealizedProfit();
   
   if(EnableTimeExit && sameDirectionCount >= 2) {
      CheckTimeExit();
      if(timeExitTriggered) return;
   }
   
   if(EnableGroupTrailing && totalEATrades > 0 && sameDirectionCount > 0) 
   {
      activationLevel = BaseProfitPerTrade * sameDirectionCount;
      
      if(totalProfit >= activationLevel) 
      {
         if(!trailingActive) 
         {
            trailingActive = true;
            peakGroupProfit = totalProfit;
            groupTrailingLevel = activationLevel - MinTrailingDistanceUSD;
            Log(StringFormat("Trailing SL ACTIVATED at $%.2f (Target: $%.2f for %d trades)", 
                             groupTrailingLevel, activationLevel, sameDirectionCount));
         }
         else 
         {
            if(totalProfit > peakGroupProfit + TrailingStepUSD) 
            {
               groupTrailingLevel = peakGroupProfit - MinTrailingDistanceUSD;
               peakGroupProfit = totalProfit;
               Log(StringFormat("Trailing SL MOVED to $%.2f", groupTrailingLevel));
            }
            
            if(totalProfit <= groupTrailingLevel) 
            {
               if(CloseAllEATrades()) 
               {
                  Log(StringFormat("Trailing SL TRIGGERED at $%.2f", groupTrailingLevel));
                  SendStatusNotification("Group trailing stop triggered: $" + DoubleToString(totalProfit, 2));
                  trailingActive = false;
               }
            }
         }
      }
   }
   
   if(totalEATrades == 0 && !hasManualTrade)
   {
      ResetEAState();
      
      if(!EnableInitialTrades) {
         if(tickCount % 30 == 0) Log("Status: Initial trades disabled");
         return;
      }
      
      if(!CheckVolumeFilter()) {
         currentStatus = "Volume too low for initial trade";
         return;
      }
      
      int emaDirection = 0;
      if(UseEMAFilter && !CheckEMAFilter(emaDirection)) {
         currentStatus = "EMA filter blocking trade";
         if(tickCount % 30 == 0) Log("Status: " + currentStatus);
         return;
      }
      
      if(CheckStrictConsecutiveCandles(direction)) {
         if(UseEMAFilter && direction != emaDirection) {
            currentStatus = "Direction doesn't match EMA";
            Log("Status: " + currentStatus);
            return;
         }
         
         initialEntryPrice = SymbolInfoDouble(currentSymbol, direction == 1 ? SYMBOL_ASK : SYMBOL_BID);
         double point = GetCurrentPoint();
         double tpPrice = initialEntryPrice + (direction == 1 ? InitialTPPips : -InitialTPPips) * PIP * point;
         
         double lotSize = InitialLotSize;
         if(UseAutoLotSize) {
            lotSize = CalculateAutoLotSize(RiskPercentPerTrade);
         }
         
         trade.SetExpertMagicNumber(MagicNumber);
         if(trade.PositionOpen(currentSymbol, direction == 1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL,
                              lotSize, initialEntryPrice, 0, tpPrice, INITIAL_COMMENT))
         {
            Log(StringFormat("Opened Initial Trade: %s %.2f lots @ %.5f (TP: %.5f)",
                            (direction == 1) ? "BUY" : "SELL",
                            lotSize,
                            initialEntryPrice,
                            tpPrice));
                            
            initialTradeOpened = true;
            sameDirectionCount = 1;
            lastMainEntryPrice = initialEntryPrice;
            initialBarTime = iTime(currentSymbol, _Period, 0);
            initialTradeOpenTime = TimeCurrent();
            dailyTrades++;
            currentStatus = StringFormat("Opened Initial Trade @ %.5f", initialEntryPrice);
            Log("Status: " + currentStatus);
            
            SendStatusNotification(currentStatus);
         }
         else {
            int error = GetLastError();
            Log(StringFormat("Failed to open initial trade! Error: %d", error));
         }
      }
      else {
         if(tickCount % 30 == 0) {
            currentStatus = "Waiting for valid candle pattern";
            Log("Status: " + currentStatus);
         }
      }
   }
   else
   {
      string statusDetails = StringFormat("Managing %d trades: %d main, %d reverse | P/L: $%.2f",
                                        totalEATrades,
                                        sameDirectionCount,
                                        reverseTradeCount,
                                        totalProfit);
      
      double customTarget = CalculateProfitTarget();
      if(customTarget > 0 && ArraySize(customProfitTargets) > 0) {
         statusDetails += StringFormat(" | Custom Target: $%.2f", customTarget);
      }
      
      if(EnableGroupTrailing && sameDirectionCount > 0) {
         activationLevel = BaseProfitPerTrade * sameDirectionCount;
         statusDetails += StringFormat(" | Dynamic Target: $%.2f", activationLevel);
      }
      
      if(trailingActive) {
         statusDetails += StringFormat(" | Trailing SL: $%.2f", groupTrailingLevel);
      }
      
      if(hasManualTrade) {
         statusDetails += " | Manual trade incorporated";
      }
      
      if(peakProfit > 0 && !EnableGroupTrailing) {
         statusDetails += StringFormat(" | Trailing: $%.2f/$%.2f", totalProfit, peakProfit - ProfitTargetUSD);
      }
      
      if(tickCount % 10 == 0 || MathAbs(totalProfit - lastProfitCheck) > 0.5) {
         currentStatus = statusDetails;
         Log("Status: " + currentStatus);
         lastProfitCheck = totalProfit;
      }
      
      if(totalProfit > peakProfit) {
         peakProfit = totalProfit;
      }
      
      if(EnableHedges && sameDirectionCount < MaxTrades) {
         ManageHedging();
      }
      
      if(EnableReverseHedging) {
         ManageReverseHedging();
      }
   }
}
//+------------------------------------------------------------------+