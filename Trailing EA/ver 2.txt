//+------------------------------------------------------------------+
//|                                                  TrailingEA.mq5  |
//|                                                                  |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "Trailing EA"
#property version   "1.00"
#property description "EA for manual trading with trailing SL/TP"

//--- Include Trade library
#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>

//--- Input parameters
input double   LotSize      = 0.1;       // Lot size
input int      StopLoss     = 200;       // Stop Loss (points)
input int      TakeProfit   = 400;       // Take Profit (points)
input int      TrailingStop = 100;       // Trailing Stop (points)
input int      TrailingStep = 50;        // Trailing step (points)
input int      MagicNumber  = 12345;     // Magic number
input int      Slippage     = 10;        // Slippage (points)
input string   TradeComment = "TrailingEA"; // Trade comment

//--- Global variables
CTrade trade;
CPositionInfo positionInfo;
double point;
bool needToSetSLTP = false;
ulong lastOpenedTicket = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   //--- Initialize trade object
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(Slippage);
   trade.SetAsyncMode(false);
   
   //--- Get point size
   point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   
   Print("Trailing EA initialized successfully");
   Print("Symbol: ", _Symbol, " Point: ", point, " Digits: ", digits);
   Print("StopLoss: ", StopLoss, " points (", NormalizeDouble(StopLoss * point, digits), ")");
   Print("TakeProfit: ", TakeProfit, " points (", NormalizeDouble(TakeProfit * point, digits), ")");
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("Trailing EA deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   //--- Check if we need to set SL/TP for recently opened position
   if(needToSetSLTP && lastOpenedTicket > 0)
   {
      if(SetSLTPForPosition(lastOpenedTicket))
      {
         needToSetSLTP = false;
         Print("SL/TP successfully set for ticket: ", lastOpenedTicket);
      }
   }
   
   //--- Manage trailing stops for all positions
   ManageTrailingStops();
}

//+------------------------------------------------------------------+
//| Open buy order                                                   |
//+------------------------------------------------------------------+
void OpenBuyOrder()
{
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double sl = NormalizeDouble(ask - (StopLoss * point), _Digits);
   double tp = NormalizeDouble(ask + (TakeProfit * point), _Digits);
   
   Print("Attempting BUY order: Price=", ask, " SL=", sl, " TP=", tp);
   
   // First try: Open with SL/TP
   if(trade.Buy(LotSize, _Symbol, ask, sl, tp, TradeComment))
   {
      lastOpenedTicket = trade.ResultOrder();
      Print("BUY order opened successfully with SL/TP. Ticket: ", lastOpenedTicket);
      needToSetSLTP = false;
   }
   else
   {
      Print("Failed to open BUY with SL/TP. Error: ", trade.ResultRetcodeDescription());
      Print("Trying alternative method...");
      
      // Alternative: Open without SL/TP and set them after
      if(trade.Buy(LotSize, _Symbol, ask, 0, 0, TradeComment))
      {
         lastOpenedTicket = trade.ResultOrder();
         Print("BUY order opened without SL/TP. Ticket: ", lastOpenedTicket);
         needToSetSLTP = true;
      }
      else
      {
         Print("Failed to open BUY order completely. Error: ", trade.ResultRetcodeDescription());
      }
   }
}

//+------------------------------------------------------------------+
//| Open sell order                                                  |
//+------------------------------------------------------------------+
void OpenSellOrder()
{
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl = NormalizeDouble(bid + (StopLoss * point), _Digits);
   double tp = NormalizeDouble(bid - (TakeProfit * point), _Digits);
   
   Print("Attempting SELL order: Price=", bid, " SL=", sl, " TP=", tp);
   
   // First try: Open with SL/TP
   if(trade.Sell(LotSize, _Symbol, bid, sl, tp, TradeComment))
   {
      lastOpenedTicket = trade.ResultOrder();
      Print("SELL order opened successfully with SL/TP. Ticket: ", lastOpenedTicket);
      needToSetSLTP = false;
   }
   else
   {
      Print("Failed to open SELL with SL/TP. Error: ", trade.ResultRetcodeDescription());
      Print("Trying alternative method...");
      
      // Alternative: Open without SL/TP and set them after
      if(trade.Sell(LotSize, _Symbol, bid, 0, 0, TradeComment))
      {
         lastOpenedTicket = trade.ResultOrder();
         Print("SELL order opened without SL/TP. Ticket: ", lastOpenedTicket);
         needToSetSLTP = true;
      }
      else
      {
         Print("Failed to open SELL order completely. Error: ", trade.ResultRetcodeDescription());
      }
   }
}

//+------------------------------------------------------------------+
//| Set SL and TP for a position                                     |
//+------------------------------------------------------------------+
bool SetSLTPForPosition(ulong ticket)
{
   if(positionInfo.SelectByTicket(ticket))
   {
      long type = positionInfo.Type();
      double openPrice = positionInfo.PriceOpen();
      double newSL = 0, newTP = 0;
      
      if(type == POSITION_TYPE_BUY)
      {
         newSL = NormalizeDouble(openPrice - (StopLoss * point), _Digits);
         newTP = NormalizeDouble(openPrice + (TakeProfit * point), _Digits);
      }
      else if(type == POSITION_TYPE_SELL)
      {
         newSL = NormalizeDouble(openPrice + (StopLoss * point), _Digits);
         newTP = NormalizeDouble(openPrice - (TakeProfit * point), _Digits);
      }
      
      // Check if SL/TP are already set
      double currentSL = positionInfo.StopLoss();
      double currentTP = positionInfo.TakeProfit();
      
      if(currentSL != 0 || currentTP != 0)
      {
         Print("Position already has SL/TP set. SL: ", currentSL, " TP: ", currentTP);
         return true;
      }
      
      if(trade.PositionModify(ticket, newSL, newTP))
      {
         Print("SL/TP modified for ticket ", ticket, " - SL: ", newSL, " TP: ", newTP);
         return true;
      }
      else
      {
         Print("Error modifying SL/TP for ticket ", ticket, ": ", trade.ResultRetcodeDescription());
         return false;
      }
   }
   else
   {
      Print("Cannot select position with ticket: ", ticket);
      return false;
   }
}

//+------------------------------------------------------------------+
//| Close all positions                                              |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   int total = PositionsTotal();
   if(total == 0)
   {
      Print("No positions to close");
      return;
   }
   
   for(int i = total-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionSelectByTicket(ticket))
      {
         string symbol = PositionGetString(POSITION_SYMBOL);
         if(symbol == _Symbol)
         {
            double volume = PositionGetDouble(POSITION_VOLUME);
            if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
            {
               trade.Sell(volume, _Symbol);
            }
            else
            {
               trade.Buy(volume, _Symbol);
            }
         }
      }
   }
   Print("All positions closed");
}

//+------------------------------------------------------------------+
//| Manage trailing stops                                            |
//+------------------------------------------------------------------+
void ManageTrailingStops()
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && positionInfo.SelectByTicket(ticket))
      {
         string symbol = positionInfo.Symbol();
         if(symbol == _Symbol)
         {
            double currentSL = positionInfo.StopLoss();
            double currentTP = positionInfo.TakeProfit();
            double openPrice = positionInfo.PriceOpen();
            long type = positionInfo.Type();
            
            // First, ensure SL/TP are set
            if(currentSL == 0 || currentTP == 0)
            {
               if(SetSLTPForPosition(ticket))
               {
                  Print("SL/TP set for existing position. Ticket: ", ticket);
               }
               return; // Wait for next tick to continue with trailing
            }
            
            if(type == POSITION_TYPE_BUY)
            {
               double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
               double newSL = NormalizeDouble(currentPrice - (TrailingStop * point), _Digits);
               double newTP = NormalizeDouble(currentPrice + (TakeProfit * point), _Digits);
               
               // Check if we should move the stop loss
               if(newSL > currentSL && newSL > openPrice)
               {
                  // Also check the step condition
                  if(newSL >= currentSL + (TrailingStep * point))
                  {
                     if(trade.PositionModify(ticket, newSL, newTP))
                     {
                        Print("Buy trailing updated - SL: ", newSL, " TP: ", newTP);
                     }
                  }
               }
            }
            else if(type == POSITION_TYPE_SELL)
            {
               double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
               double newSL = NormalizeDouble(currentPrice + (TrailingStop * point), _Digits);
               double newTP = NormalizeDouble(currentPrice - (TakeProfit * point), _Digits);
               
               // Check if we should move the stop loss
               if((newSL < currentSL || currentSL == 0) && newSL < openPrice)
               {
                  // Also check the step condition
                  if(newSL <= currentSL - (TrailingStep * point) || currentSL == 0)
                  {
                     if(trade.PositionModify(ticket, newSL, newTP))
                     {
                        Print("Sell trailing updated - SL: ", newSL, " TP: ", newTP);
                     }
                  }
               }
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Chart Event function                                             |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
   if(id == CHARTEVENT_OBJECT_CLICK)
   {
      string clicked = sparam;
      
      if(clicked == "BuyButton")
      {
         OpenBuyOrder();
      }
      else if(clicked == "SellButton")
      {
         OpenSellOrder();
      }
      else if(clicked == "CloseAllButton")
      {
         CloseAllPositions();
      }
      else if(clicked == "SetSLTPButton")
      {
         // Set SL/TP for all existing positions
         for(int i = 0; i < PositionsTotal(); i++)
         {
            ulong ticket = PositionGetTicket(i);
            if(ticket > 0 && positionInfo.SelectByTicket(ticket))
            {
               if(positionInfo.Symbol() == _Symbol)
               {
                  SetSLTPForPosition(ticket);
               }
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Create control buttons                                           |
//+------------------------------------------------------------------+
void CreateButtons()
{
   // Buy Button
   ObjectCreate(0, "BuyButton", OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, "BuyButton", OBJPROP_XDISTANCE, 10);
   ObjectSetInteger(0, "BuyButton", OBJPROP_YDISTANCE, 50);
   ObjectSetInteger(0, "BuyButton", OBJPROP_XSIZE, 80);
   ObjectSetInteger(0, "BuyButton", OBJPROP_YSIZE, 30);
   ObjectSetString(0, "BuyButton", OBJPROP_TEXT, "BUY");
   ObjectSetInteger(0, "BuyButton", OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, "BuyButton", OBJPROP_BGCOLOR, clrGreen);
   
   // Sell Button
   ObjectCreate(0, "SellButton", OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, "SellButton", OBJPROP_XDISTANCE, 100);
   ObjectSetInteger(0, "SellButton", OBJPROP_YDISTANCE, 50);
   ObjectSetInteger(0, "SellButton", OBJPROP_XSIZE, 80);
   ObjectSetInteger(0, "SellButton", OBJPROP_YSIZE, 30);
   ObjectSetString(0, "SellButton", OBJPROP_TEXT, "SELL");
   ObjectSetInteger(0, "SellButton", OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, "SellButton", OBJPROP_BGCOLOR, clrRed);
   
   // Close All Button
   ObjectCreate(0, "CloseAllButton", OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, "CloseAllButton", OBJPROP_XDISTANCE, 190);
   ObjectSetInteger(0, "CloseAllButton", OBJPROP_YDISTANCE, 50);
   ObjectSetInteger(0, "CloseAllButton", OBJPROP_XSIZE, 80);
   ObjectSetInteger(0, "CloseAllButton", OBJPROP_YSIZE, 30);
   ObjectSetString(0, "CloseAllButton", OBJPROP_TEXT, "CLOSE ALL");
   ObjectSetInteger(0, "CloseAllButton", OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, "CloseAllButton", OBJPROP_BGCOLOR, clrBlue);
   
   // Set SL/TP Button
   ObjectCreate(0, "SetSLTPButton", OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, "SetSLTPButton", OBJPROP_XDISTANCE, 280);
   ObjectSetInteger(0, "SetSLTPButton", OBJPROP_YDISTANCE, 50);
   ObjectSetInteger(0, "SetSLTPButton", OBJPROP_XSIZE, 80);
   ObjectSetInteger(0, "SetSLTPButton", OBJPROP_YSIZE, 30);
   ObjectSetString(0, "SetSLTPButton", OBJPROP_TEXT, "SET SL/TP");
   ObjectSetInteger(0, "SetSLTPButton", OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, "SetSLTPButton", OBJPROP_BGCOLOR, clrOrange);
}